use import std.array
use import std.map
use import std.box
use import std.string
use import std.math
use import std.matrix
use import std.rc
use import std.thread

mem :: import std.mem.allocator
fmt :: import std.fmt
io  :: import std.io
C   :: import std.c
fs  :: import std.io.fs

use import glfw
use import vulkan
use import vulkan_utils
use import spirv_cross

vk :: import vulkan_hl

MaxFramesInFlight :: 2

enable_validation_layers :: true
validation_layers := [
    "VK_LAYER_KHRONOS_validation"c
]
device_extensions := [
    VK_KHR_SWAPCHAIN_EXTENSION_NAME
]

glfw_error_callback :: (error: i32, description: ^mut char8) {
    desc := String.from_cstring(description)
    io.formatln("Glfw Error {}: {}", [error, desc.slice()])
}

vulkan_debug_callback :: (
    messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT,
    messageType: VkDebugUtilsMessageTypeFlagsEXT,
    pCallbackData: ^mut VkDebugUtilsMessengerCallbackDataEXT,
    pUserData: ^mut void) -> VkBool32 #stdcall {

    if i32(messageSeverity) >= i32(VkDebugUtilsMessageSeverityFlagBitsEXT.WarningBitExt) {
        level := match messageSeverity {
            .VerboseBitExt  -> "Verbose"
            .InfoBitExt     -> "Info"
            .WarningBitExt  -> "Warning"
            .ErrorBitExt    -> "Error"
            _               -> "?"
        }

        io.formatln("[Vulkan {}] {}", [level, string.from_cstring(pCallbackData.pMessage)])
    }

    return VK_FALSE
}

Main :: () {
    hello_triangle_app := HelloTriangleApplication.new()

    match hello_triangle_app.run() {
        Ok(_) -> {}
        Err($msg) -> {
            io.formatln("[Vulkan Error] {}", [msg])
        }
    }
}

VulkanContext :: struct {
    instance        : vk.Instance
    debug_messenger : vk.DebugUtilsMessenger
    surface         : vk.Surface
    physical_device : vk.PhysicalDevice
    device          : vk.Device
    graphics_queue  : vk.Queue
    present_queue   : vk.Queue
    graphics_queue_family : u32
    present_queue_family  : u32
}

impl VulkanContext {
    destroy :: (&Self) {
        self.device.destroy()
        self.surface.destroy()
        self.debug_messenger.destroy()
        self.instance.destroy()
    }
}

impl Drop for VulkanContext {
    drop :: (&Self) {
        self.destroy()
    }
}

impl VulkanContext {
    new :: (window: ^GLFWwindow) -> Result[^mut VulkanContext, vk.Error] {
        validation_info := vk.ValidationInfo(
            message_severity = .VerboseBitExt or .InfoBitExt or .WarningBitExt or .ErrorBitExt
            message_type     = .GeneralBitExt or .ValidationBitExt or .PerformanceBitExt
            user_callback    = vulkan_debug_callback
            user_data        = null
        )


        device_extensions := [string.from_cstring(VK_KHR_SWAPCHAIN_EXTENSION_NAME)]

        extensions := Array[string].new()

        // add extensions for glfw
        mut glfw_extensions : []^char8 = default
        glfw_extensions.data = glfwGetRequiredInstanceExtensions(cast ^mut glfw_extensions.length)
        for glfw_ext in glfw_extensions {
            extensions.add(string.from_cstring(glfw_ext))
        }

        instance := try(vk.Instance.new(
            api_version = Some(vk.Version((1, 2, 0)))
            validation  = Some(validation_info)
            extensions = extensions[..]
        ))

        debug_messenger := try(instance.create_debug_messenger(validation_info))
        surface := try(instance.create_surface_glfw(window))

        // find suitable physical device
        physical_devices := try(instance.enumerate_physical_devices())

        suitable_physical_devices := vk.PhysicalDevice.filter_by_requirements(physical_devices[..],
            extensions = device_extensions
            queues     = [vk.QueueFlags.GraphicsBit or .TransferBit]
            present    = Some(&surface)
            swapchain  = Some(&surface)
        )

        if suitable_physical_devices.count() == 0 {
            return Err(vk.Error.NoPhysicalDevice)
        }

        physical_device := *suitable_physical_devices[0]
        graphics_families := physical_device.get_queue_families_with(.GraphicsBit or .TransferBit)
        present_families := physical_device.get_queue_families_with_present(&surface)

        graphics_family := *graphics_families[0]
        present_family := *present_families[0]

        // create device
        unique_queue_families := Map[u32, ()].new()
        unique_queue_families.set(graphics_family, ())
        unique_queue_families.set(present_family, ())

        queue_create_infos := Array[vk.DeviceQueueCreateInfo].new(unique_queue_families.count())
        for kv in &unique_queue_families {
            queue_create_infos.add(vk.DeviceQueueCreateInfo(
                family      = *kv.key
                priorities  = [1.0]
            ))
        }

        features12 := VkPhysicalDeviceVulkan12Features(
            sType = .PhysicalDeviceVulkan12Features
            hostQueryReset = 1
        )

        features := VkPhysicalDeviceFeatures2(
            sType = .PhysicalDeviceFeatures2
            pNext = ^features12
            features = VkPhysicalDeviceFeatures()
        )
        device := try(vk.Device.new(physical_device,
            extensions = device_extensions
            queues = queue_create_infos[..]
            features = ^features))
        graphics_queue := device.get_queue(graphics_family)
        present_queue := device.get_queue(present_family)

        result := mem.alloc(VulkanContext)
        *result = VulkanContext(
            instance        = instance
            debug_messenger = debug_messenger
            surface         = surface
            physical_device = *physical_device
            device          = device
            graphics_queue  = graphics_queue
            present_queue   = present_queue
            graphics_queue_family = graphics_family
            present_queue_family  = present_family
        )
        return Ok(result)
    }
}

FrameData :: struct {
    command_buffer  : VkCommandBuffer = default
    sema_acquire    : VkSemaphore = default
    sema_render     : VkSemaphore = default
    fence_draw_done : VkFence = default
    query_pool      : VkQueryPool = default
    query_results   : [2]u64 = default
}

FrameStatistics :: struct {
    avg_speed   := 0.02
    total_time  := 0.0
    cpu_time    := 0.0
    wait_time   := 0.0
    gpu_time    := 0.0
}

HelloTriangleApplication :: struct {
    // window stuff
    window                  : ^mut GLFWwindow = null
    window_size             : (x: i32, y: i32) = 800, 600

    current_frame           := 0
    framebuffer_resized     := false

    // vulkan stuff
    context                 : ^VulkanContext = null

    surface_capabilities    := Option[vk.PhysicalDeviceSurfaceCapabilities].None
    swapchain_format        : VkSurfaceFormatKHR = default
    swapchain               := Rc[vk.Swapchain].empty()

    render_pass             : VkRenderPass = null
    pipeline_layout         : VkPipelineLayout = null
    graphics_pipeline       : VkPipeline = null

    command_pool            : VkCommandPool = null

    frames                  := Array[FrameData].new()
    command_buffers         := Array[VkCommandBuffer].new()
    sema_image_available    := Array[VkSemaphore].new()
    sema_render_finished    := Array[VkSemaphore].new()
    fences_in_flight        := Array[VkFence].new()
    images_in_flight        := Array[VkFence].new()

    frame_statistics        := FrameStatistics()

    // query_result_buffer     : VkBuffer = null
    // query_result_buffer_mem : VkDeviceMemory = null
    // query_result_buffer_ptr : []u64 = []
}

impl HelloTriangleApplication {
    new :: () -> HelloTriangleApplication {
        return HelloTriangleApplication()
    }

    get_memory_type :: (&mut Self, memory_type_bits: u32, flags: VkMemoryPropertyFlagBits) -> Option[u32] {
        mut properties : VkPhysicalDeviceMemoryProperties = default
        vkGetPhysicalDeviceMemoryProperties(self.context.physical_device.handle, ^mut properties)
        for typ in properties.memoryTypes[..i64(properties.memoryTypeCount)] {
            is_possible_type := @bin_and(@bin_lsl(1, u32(it_index)), memory_type_bits) != 0
            if is_possible_type and (flags is in typ.propertyFlags) {
                return .Some(u32(it_index))
            }
        }
        return .None
    }

    create_buffer :: (&mut Self, size: u64) -> Result[(VkBuffer, VkDeviceMemory), String] {
        queue_families := [self.context.graphics_queue_family]
        create_info := VkBufferCreateInfo(
            sType = .BufferCreateInfo
            size  = size
            usage = .TransferDstBit
            sharingMode = .Exclusive
            queueFamilyIndexCount = cast queue_families.length
            pQueueFamilyIndices = queue_families.data
        )

        mut buffer : VkBuffer = default
        vk_try(vkCreateBuffer(self.context.device.handle, ^create_info, null, ^mut buffer))

        memory_requirements := VkMemoryRequirements()
        vkGetBufferMemoryRequirements(self.context.device.handle, buffer, ^mut memory_requirements)
        allocation_info := VkMemoryAllocateInfo(
            sType = .MemoryAllocateInfo
            allocationSize = memory_requirements.size
            memoryTypeIndex = self.get_memory_type(memory_requirements.memoryTypeBits, .HostVisibleBit or .HostCoherentBit).unwrap()
        )

        mut memory : VkDeviceMemory = default
        vk_try(vkAllocateMemory(self.context.device.handle, ^allocation_info, null, ^mut memory))
        vk_try(vkBindBufferMemory(self.context.device.handle, buffer, memory, 0))

        return Ok(buffer, memory)
    }

    run :: (&mut Self) -> Result[(), String] {
        defer self.cleanup()

        // init stuff
        try(self.init_window())
        try(self.init_vulkan())

        for i in 0 .. MaxFramesInFlight {
            semaphore_info := VkSemaphoreCreateInfo(
                sType = .SemaphoreCreateInfo
            )

            fence_info := VkFenceCreateInfo(
                sType = .FenceCreateInfo
                flags = .SignaledBit
            )

            mut frame := FrameData()
            vk_assert(vkCreateSemaphore(self.context.device.handle, ^semaphore_info, null, ^mut frame.sema_acquire))
            vk_assert(vkCreateSemaphore(self.context.device.handle, ^semaphore_info, null, ^mut frame.sema_render))
            vk_assert(vkCreateFence(self.context.device.handle, ^fence_info, null, ^mut frame.fence_draw_done))

            alloc_info := VkCommandBufferAllocateInfo(
                sType              = .CommandBufferAllocateInfo
                commandPool        = self.command_pool
                level              = .Primary
                commandBufferCount = 1
            )

            vk_assert(vkAllocateCommandBuffers(self.context.device.handle, ^alloc_info, ^mut frame.command_buffer))

            query_pool_info := VkQueryPoolCreateInfo(
                sType               = .QueryPoolCreateInfo
                queryType           = .Timestamp
                queryCount          = 100
                pipelineStatistics  = .None
            )
            vk_try(vkCreateQueryPool(self.context.device.handle, ^query_pool_info, null, ^mut frame.query_pool))

            self.frames.add(frame)
        }

        // (self.query_result_buffer, self.query_result_buffer_mem) = try(self.create_buffer(100 * @sizeof(u64)))
        // vk_try(vkMapMemory(self.context.device.handle, self.query_result_buffer_mem, 0, 100 * @sizeof(u64), .None, cast ^mut self.query_result_buffer_ptr.data))
        // self.query_result_buffer_ptr.length = 100

        self.main_loop()

        return Ok()
    }
    
    cleanup_swapchain :: (&mut Self) {
        for(by_ref=false) framebuffer in self.swapchain.get().get_framebuffers() {
            if framebuffer != null then vkDestroyFramebuffer(self.context.device.handle, framebuffer, null)
        }

        vkFreeCommandBuffers(self.context.device.handle, self.command_pool, cast self.command_buffers.count(), self.command_buffers.get_raw_mut())

        for(by_ref=false) view in self.swapchain.get().get_image_views() {
            if view != null then vkDestroyImageView(self.context.device.handle, view, null)
        }

        swapchain.get().destroy()
    }

    cleanup :: (&mut Self) {
        for(by_ref=true) frame in self.frames[..] {
            vkDestroyFence(self.context.device.handle, frame.fence_draw_done, null)
            vkDestroySemaphore(self.context.device.handle, frame.sema_acquire, null)
            vkDestroySemaphore(self.context.device.handle, frame.sema_render, null)
            vkDestroyQueryPool(self.context.device.handle, frame.query_pool, null)
        }

        if graphics_pipeline != null then vkDestroyPipeline(self.context.device.handle, graphics_pipeline, null)
        if pipeline_layout   != null then vkDestroyPipelineLayout(self.context.device.handle, pipeline_layout, null)

        self.cleanup_swapchain()
        if render_pass != null then vkDestroyRenderPass(self.context.device.handle, render_pass, null)
        for i in 0 .. MaxFramesInFlight {
            if *sema_render_finished[i] != null then vkDestroySemaphore(self.context.device.handle, *sema_render_finished[i], null)
            if *sema_image_available[i] != null then vkDestroySemaphore(self.context.device.handle, *sema_image_available[i], null)
            if *fences_in_flight[i] != null then vkDestroyFence(self.context.device.handle, *fences_in_flight[i], null)
        }

        if command_pool != null then vkDestroyCommandPool(self.context.device.handle, command_pool, null)

        self.context.destroy()
        mem.free(self.context)

        // glfw
        if window != null then glfwDestroyWindow(window)
        glfwTerminate()
    }

    main_loop :: (&mut Self) {
        glfwShowWindow(window)
        mut window_title := String.empty()

        while glfwWindowShouldClose(window) == 0 {
            cpu_start := glfwGetTime()
            glfwPollEvents()
            draw_frame()
            cpu_end := glfwGetTime()

            { // calculate timing and set title
                frame := self.frames[(self.current_frame + self.frames.count() - 1) % self.frames.count()]
                timestamp_period := f64(self.context.physical_device.properties.limits.timestampPeriod)

                self.frame_statistics.cpu_time = self.frame_statistics.avg_speed * (cpu_end - cpu_start) * 1000.0 + (1 - self.frame_statistics.avg_speed) * self.frame_statistics.cpu_time
                self.frame_statistics.gpu_time = self.frame_statistics.avg_speed * f64(*frame.query_results[1] - *frame.query_results[0]) * timestamp_period * 0.000001 + (1 - self.frame_statistics.avg_speed) * self.frame_statistics.gpu_time

                mut fps := 0.0
                if self.frame_statistics.cpu_time != 0 {
                    fps = 1000.0 / self.frame_statistics.cpu_time
                }

                window_title.clear()
                fmt.format_into(&mut window_title, "Vulkan Test - CPU: {:.2}ms, wait: {:.2}ms ({:.1} fps), GPU: {:.2}ms", [
                    self.frame_statistics.cpu_time, self.frame_statistics.wait_time, fps
                    self.frame_statistics.gpu_time
                ])
                glfwSetWindowTitle(self.window, cast window_title.as_cstring())
            }
        }

        vkDeviceWaitIdle(self.context.device.handle)
    }

    draw_frame :: (&mut Self) {
        defer { self.current_frame = (self.current_frame + 1) % self.frames.count() }
        frame : &mut FrameData = self.frames[self.current_frame]

        // acquire image
        image_index : u32 = default
        match vkAcquireNextImageKHR(self.context.device.handle, self.swapchain.get().handle, u64.max, frame.sema_acquire, null, ^image_index) {
            .Success -> {}
            .SuboptimalKhr -> {}

            .ErrorOutOfDateKhr -> {
                self.recreate_swapchains()
                return
            }

            $err -> {
                io.formatln("[Vulkan Error] vkAcquireNextImageKHR returned {}", [err])
                @assert(false)
            }
        }

        // wait for previous frame to be finished
        wait_start := glfwGetTime()
        vk_assert(vkWaitForFences(self.context.device.handle, 1, ^frame.fence_draw_done, VK_TRUE, u64.max))
        wait_end := glfwGetTime()
        self.frame_statistics.wait_time = self.frame_statistics.avg_speed * (wait_end - wait_start) * 1000.0 + (1 - self.frame_statistics.avg_speed) * self.frame_statistics.wait_time
        vkGetQueryPoolResults(self.context.device.handle, frame.query_pool, 0, cast frame.query_results.length, @sizeof(@typeof(frame.query_results)), cast frame.query_results.data, @sizeof(u64), ._64Bit)

        // render frame
        sema_render := [frame.sema_render]
        sema_acquire := [frame.sema_acquire]
        {
            vkResetCommandBuffer(frame.command_buffer, .None)
            begin_info := VkCommandBufferBeginInfo(
                sType = .CommandBufferBeginInfo
            )

            vk_assert(vkBeginCommandBuffer(frame.command_buffer, ^begin_info))

            vkCmdResetQueryPool(frame.command_buffer, frame.query_pool, 0, 100)
            vkCmdWriteTimestamp(frame.command_buffer, .BottomOfPipeBit, frame.query_pool, 0)

            clear_color := VkClearValue.color(VkClearColorValue.float32([0.1, 0.1, 0.1, 1.0]))
            render_pass_info := VkRenderPassBeginInfo(
                sType           = .RenderPassBeginInfo
                renderPass      = self.render_pass
                framebuffer     = *self.swapchain.get().get_framebuffers()[int(image_index)]
                renderArea      = VkRect2D(
                    offset      = VkOffset2D(0, 0)
                    extent      = self.swapchain.get().extent
                )
                clearValueCount = 1
                pClearValues    = ^clear_color
            )
            vkCmdBeginRenderPass(frame.command_buffer, ^render_pass_info, .Inline)
            vkCmdBindPipeline(frame.command_buffer, .Graphics, self.graphics_pipeline)
            
            viewport := VkViewport(
                x        = 0.0
                y        = 0.0
                width    = cast(float) self.swapchain.get().extent.width
                height   = cast(float) self.swapchain.get().extent.height
                minDepth = 0.0
                maxDepth = 1.0
            )

            scissor := VkRect2D(
                offset = VkOffset2D(0, 0)
                extent = self.swapchain.get().extent
            )

            vkCmdSetViewport(frame.command_buffer, 0, 1, ^viewport)
            vkCmdSetScissor(frame.command_buffer, 0, 1, ^scissor)

            for 0..1 {
                vkCmdDraw(frame.command_buffer, 3, 1, 0, 0)
            }
            vkCmdEndRenderPass(frame.command_buffer)
            vkCmdWriteTimestamp(frame.command_buffer, .BottomOfPipeBit, frame.query_pool, 1)

            vk_assert(vkEndCommandBuffer(frame.command_buffer))

            wait_stages := [VkPipelineStageFlagBits.ColorAttachmentOutputBit]
            submit_info := VkSubmitInfo(
                sType                = .SubmitInfo
                waitSemaphoreCount   = cast sema_acquire.length
                pWaitSemaphores      = sema_acquire.data
                pWaitDstStageMask    = wait_stages.data
                commandBufferCount   = 1
                pCommandBuffers      = ^frame.command_buffer
                signalSemaphoreCount = cast sema_render.length
                pSignalSemaphores    = sema_render.data
            )

            vkResetFences(self.context.device.handle, 1, ^frame.fence_draw_done)
            vk_assert(vkQueueSubmit(self.context.graphics_queue.handle, 1, ^submit_info, frame.fence_draw_done))
        }

        // present image
        swapchains := [self.swapchain.get().handle]
        present_info := VkPresentInfoKHR(
            sType              = .PresentInfoKhr
            waitSemaphoreCount = cast sema_render.length
            pWaitSemaphores    = sema_render.data
            swapchainCount     = cast swapchains.length
            pSwapchains        = swapchains.data
            pImageIndices      = ^image_index
            pResults           = null
        )
        match vkQueuePresentKHR(self.context.present_queue.handle, ^present_info) {
            .Success -> {}
            .SuboptimalKhr -> {}

            .ErrorOutOfDateKhr -> {
                self.recreate_swapchains()
                return
            }

            $err -> {
                io.formatln("[Vulkan Error] vkQueuePresentKHR returned {}", [err])
                @assert(false)
            }
        }

        if self.framebuffer_resized {
            self.recreate_swapchains()
            return
        }
    }
}

// window stuff
impl HelloTriangleApplication {
    init_window :: (&mut Self) -> Result[(), String] {
        glfwSetErrorCallback(glfw_error_callback)

        if glfwInit() == 0 {
            return Err(fmt.format("Failed to initialize GLFW"))
        }

        glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE)
        glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE)
        glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API)

        mut monitors: []mut ^mut GLFWmonitor = []
        monitors.data = glfwGetMonitors(cast ^mut monitors.length)

        @assert(monitors.length > 0)

        window = glfwCreateWindow(self.window_size.x, self.window_size.y, "Vulkan Test", null, null)
        if window == null {
            return Err(fmt.format("Failed to create window"))
        }

        // center window on monitor
        monitor := *monitors[0]
        vidmode := glfwGetVideoMode(monitor)
        monitor_pos : (x: i32, y: i32) = default
        glfwGetMonitorPos(monitor, ^monitor_pos.x, ^monitor_pos.y)
        glfwSetWindowPos(window, monitor_pos.x + vidmode.width / 2 - self.window_size.x / 2, monitor_pos.y + vidmode.height / 2 - self.window_size.y / 2)

        glfwSetWindowUserPointer(window, ^mut *self)

        glfwSetWindowSizeCallback(window, (window, width, height) => {
            app := cast(^mut HelloTriangleApplication) glfwGetWindowUserPointer(window)
            app.framebuffer_resized = true
        })

        return Ok()
    }
}

// vulkan stuff
impl HelloTriangleApplication {
    init_vulkan :: (&mut Self) -> Result[(), String] {
        self.context = try_with(VulkanContext.new(self.window), { return Err(fmt.format("Failed to create context: {}", [err])) })
        self.surface_capabilities = Some(self.context.physical_device.query_swapchain_support(&self.context.surface))
        self.swapchain_format = self.surface_capabilities.unwrap_ref().choose_swap_surface_format(.R8g8b8a8Srgb, .SrgbNonlinearKhr)

        try(self.create_command_pool())
        
        mut window_extent := VkExtent2D()
        glfwGetFramebufferSize(self.window, cast ^mut window_extent.width, cast ^mut window_extent.height)

        self.swapchain = try_with(vk.Swapchain.new(
            device                  = &self.context.device
            physical_device         = &self.context.physical_device
            surface                 = &self.context.surface
            queue_family_indices    = [self.context.graphics_queue_family, self.context.present_queue_family]
            extent                  = self.surface_capabilities.unwrap_ref().choose_swap_extent(window_extent)
            image_format            = self.swapchain_format.format
            color_space             = self.swapchain_format.colorSpace
            present_mode            = self.surface_capabilities.unwrap_ref().choose_swap_present_mode(.MailboxKhr)
            image_count             = self.surface_capabilities.unwrap_ref().choose_image_count()
            pre_transform           = self.surface_capabilities.unwrap_ref().capabilities.currentTransform
        ), { return Err(fmt.format("Failed to create swapchain: {}", [err])) })

        try(self.create_render_pass())
        try(self.create_graphics_pipeline())

        try_with(self.swapchain.get_mut().create_image_views(), { return Err(fmt.format("Failed to create swapchain image views: {}", [err])) })
        try_with(self.swapchain.get_mut().create_framebuffers(self.render_pass), { return Err(fmt.format("Failed to create swapchain framebuffers: {}", [err])) })
        try(self.create_command_buffers())
        try(self.create_sync_objects())

        return Ok()
    }

    recreate_swapchains :: (&mut Self) -> Result[(), String] {
        self.framebuffer_resized = false

        mut window_extent := VkExtent2D()
        glfwGetFramebufferSize(self.window, cast ^mut window_extent.width, cast ^mut window_extent.height)
        while window_extent.width == 0 or window_extent.height == 0 {
            glfwGetFramebufferSize(self.window, cast ^mut window_extent.width, cast ^mut window_extent.height)
            glfwWaitEvents()
        }

        vkDeviceWaitIdle(self.context.device.handle)
        self.cleanup_swapchain()
        self.surface_capabilities.unwrap_ref_mut().update_capabilities(&self.context.surface)

        // create new swapchain
        self.swapchain = try_with(vk.Swapchain.new(
            device                  = &self.context.device
            physical_device         = &self.context.physical_device
            surface                 = &self.context.surface
            queue_family_indices    = [self.context.graphics_queue_family, self.context.present_queue_family]
            extent                  = self.surface_capabilities.unwrap_ref().choose_swap_extent(window_extent)
            image_format            = self.swapchain_format.format
            color_space             = self.swapchain_format.colorSpace
            present_mode            = self.surface_capabilities.unwrap_ref().choose_swap_present_mode(.MailboxKhr)
            image_count             = self.surface_capabilities.unwrap_ref().choose_image_count()
            pre_transform           = self.surface_capabilities.unwrap_ref().capabilities.currentTransform
        ), { return Err(fmt.format("Failed to create swapchain: {}", [err])) })
        try_with(self.swapchain.get_mut().create_image_views(), { return Err(fmt.format("Failed to create swapchain image views: {}", [err])) })
        try_with(self.swapchain.get_mut().create_framebuffers(self.render_pass), { return Err(fmt.format("Failed to create swapchain framebuffers: {}", [err])) })
        try(self.create_command_buffers())

        return Ok()
    }

    //////////////////////////////////////////
    // stuff for creating render pass
    //////////////////////////////////////////

    create_render_pass :: (&mut Self) -> Result[(), String] {
        color_attachment := VkAttachmentDescription(
            format         = self.swapchain.get().image_format
            samples        = ._1Bit
            loadOp         = .Clear
            storeOp        = .Store
            stencilLoadOp  = .DontCare
            stencilStoreOp = .DontCare
            initialLayout  = .Undefined
            finalLayout    = .PresentSrcKhr
        )

        color_attachment_ref := VkAttachmentReference(
            attachment = 0
            layout     = .ColorAttachmentOptimal
        )

        subpass := VkSubpassDescription(
            pipelineBindPoint       = .Graphics
            inputAttachmentCount    = 0
            pInputAttachments       = null
            colorAttachmentCount    = 1
            pColorAttachments       = ^color_attachment_ref
            pResolveAttachments     = null
            pDepthStencilAttachment = null
            preserveAttachmentCount = 0
            pPreserveAttachments    = null
        )

        dependency := VkSubpassDependency(
            srcSubpass      = VK_SUBPASS_EXTERNAL
            dstSubpass      = 0
            srcStageMask    = .ColorAttachmentOutputBit
            dstStageMask    = .ColorAttachmentOutputBit
            srcAccessMask   = .None
            dstAccessMask   = .ColorAttachmentWriteBit
        )

        render_pass_info := VkRenderPassCreateInfo(
            sType           = .RenderPassCreateInfo
            attachmentCount = 1
            pAttachments    = ^color_attachment
            subpassCount    = 1
            pSubpasses      = ^subpass
            dependencyCount = 1
            pDependencies   = ^dependency
        )

        vk_try(vkCreateRenderPass(self.context.device.handle, ^render_pass_info, null, ^mut self.render_pass))

        return Ok()
    }

    //////////////////////////////////////////
    // stuff for creating pipeline
    //////////////////////////////////////////

    create_shader_module :: (&mut Self, code: []u8) -> Result[VkShaderModule, String] {
        create_info := VkShaderModuleCreateInfo(
            sType    = .ShaderModuleCreateInfo
            codeSize = cast code.length
            pCode    = cast(^mut u32) code.data
        )

        mut shader_module : VkShaderModule = default
        vk_try(vkCreateShaderModule(self.context.device.handle, ^create_info, null, ^mut shader_module))

        return Ok(shader_module)
    }

    create_graphics_pipeline :: (&mut Self) -> Result[(), String] {
        vert_shader_code := try_with(fs.read_file_binary("triangle.vert.spv"), { return Err(fmt.format("Failed to load vertex shader: {}", [err])) })
        frag_shader_code := try_with(fs.read_file_binary("triangle.frag.spv"), { return Err(fmt.format("Failed to load fragment shader: {}", [err])) })

        vert_shader_module := try(self.create_shader_module(vert_shader_code.slice()))
        defer vkDestroyShaderModule(self.context.device.handle, vert_shader_module, null)

        frag_shader_module := try(self.create_shader_module(frag_shader_code.slice()))
        defer vkDestroyShaderModule(self.context.device.handle, frag_shader_module, null)

        vert_shader_stage_info := VkPipelineShaderStageCreateInfo(
            sType               = .PipelineShaderStageCreateInfo
            stage               = .VertexBit
            module              = vert_shader_module
            pName               = "main"c
        )

        frag_shader_stage_info := VkPipelineShaderStageCreateInfo(
            sType               = .PipelineShaderStageCreateInfo
            stage               = .FragmentBit
            module              = frag_shader_module
            pName               = "main"c
        )

        shader_stages := [vert_shader_stage_info, frag_shader_stage_info]

        vertex_input_info := VkPipelineVertexInputStateCreateInfo(
            sType                           = .PipelineVertexInputStateCreateInfo
            vertexBindingDescriptionCount   = 0
            pVertexBindingDescriptions      = null
            vertexAttributeDescriptionCount = 0
            pVertexAttributeDescriptions    = null
        )

        input_assembly := VkPipelineInputAssemblyStateCreateInfo(
            sType                  = .PipelineInputAssemblyStateCreateInfo
            topology               = .TriangleList
            primitiveRestartEnable = VK_FALSE
        )

        viewport_state := VkPipelineViewportStateCreateInfo(
            sType         = .PipelineViewportStateCreateInfo
            viewportCount = 1
            pViewports    = null
            scissorCount  = 1
            pScissors     = null
        )

        rasterizer := VkPipelineRasterizationStateCreateInfo(
            sType                   = .PipelineRasterizationStateCreateInfo
            depthClampEnable        = VK_FALSE
            rasterizerDiscardEnable = VK_FALSE
            polygonMode             = .Fill
            cullMode                = .BackBit
            frontFace               = .Clockwise
            depthBiasEnable         = VK_FALSE
            depthBiasConstantFactor = 0.0
            depthBiasClamp          = 0.0
            depthBiasSlopeFactor    = 0.0
            lineWidth               = 1.0
        )

        multisampling := VkPipelineMultisampleStateCreateInfo(
            sType                 = .PipelineMultisampleStateCreateInfo
            rasterizationSamples  = ._1Bit
            sampleShadingEnable   = VK_FALSE
            minSampleShading      = 1.0
            pSampleMask           = null
            alphaToCoverageEnable = VK_FALSE
            alphaToOneEnable      = VK_FALSE
        )

        color_blend_attachment := VkPipelineColorBlendAttachmentState(
            blendEnable         = VK_FALSE
            srcColorBlendFactor = .One
            dstColorBlendFactor = .Zero
            colorBlendOp        = .Add
            srcAlphaBlendFactor = .One
            dstAlphaBlendFactor = .Zero
            alphaBlendOp        = .Add
            colorWriteMask      = .RBit or .GBit or .BBit or .ABit
        )

        color_blending := VkPipelineColorBlendStateCreateInfo(
            sType           = .PipelineColorBlendStateCreateInfo
            logicOpEnable   = VK_FALSE
            logicOp         = .Copy
            attachmentCount = 1
            pAttachments    = ^color_blend_attachment
            blendConstants  = [0.0, 0.0, 0.0, 0.0]
        )

        pipline_layout_info := VkPipelineLayoutCreateInfo(
            sType                  = .PipelineLayoutCreateInfo
            setLayoutCount         = 0
            pSetLayouts            = null
            pushConstantRangeCount = 0
            pPushConstantRanges    = null
        )

        vk_try(vkCreatePipelineLayout(self.context.device.handle, ^pipline_layout_info, null, ^mut self.pipeline_layout))

        mut dynamic_states : []VkDynamicState = [ VkDynamicState.Scissor, VkDynamicState.Viewport ]
        dynamic_state := VkPipelineDynamicStateCreateInfo(
            sType               = .PipelineDynamicStateCreateInfo
            dynamicStateCount   = cast dynamic_states.length
            pDynamicStates      = cast(^mut VkDynamicState) dynamic_states.data
        )

        pipeline_info := VkGraphicsPipelineCreateInfo(
            sType               = .GraphicsPipelineCreateInfo
            stageCount          = 2
            pStages             = shader_stages.data
            pVertexInputState   = ^vertex_input_info
            pInputAssemblyState = ^input_assembly
            pTessellationState  = null
            pViewportState      = ^viewport_state
            pRasterizationState = ^rasterizer
            pMultisampleState   = ^multisampling
            pDepthStencilState  = null
            pColorBlendState    = ^color_blending
            pDynamicState       = ^dynamic_state
            layout              = self.pipeline_layout
            renderPass          = self.render_pass
            subpass             = 0
            basePipelineHandle  = null
            basePipelineIndex   = -1
        )

        vk_try(vkCreateGraphicsPipelines(self.context.device.handle, null, 1, ^pipeline_info, null, ^mut self.graphics_pipeline))

        return Ok()
    }
    
    //////////////////////////////////////////
    // stuff for creating command pool
    //////////////////////////////////////////

    create_command_pool :: (&mut Self) -> Result[(), String] {
        pool_info := VkCommandPoolCreateInfo(
            sType            = .CommandPoolCreateInfo
            flags            = .ResetCommandBufferBit
            queueFamilyIndex = self.context.graphics_queue_family
        )

        vk_try(vkCreateCommandPool(self.context.device.handle, ^pool_info, null, ^mut self.command_pool))

        return Ok()
    }

    //////////////////////////////////////////
    // stuff for creating command buffers
    //////////////////////////////////////////

    create_command_buffers :: (&mut Self) -> Result[(), String] {
        self.command_buffers.resize(self.swapchain.get().get_framebuffers().length)

        alloc_info := VkCommandBufferAllocateInfo(
            sType              = .CommandBufferAllocateInfo
            commandPool        = self.command_pool
            level              = .Primary
            commandBufferCount = cast self.command_buffers.count()
        )

        vk_try(vkAllocateCommandBuffers(self.context.device.handle, ^alloc_info, self.command_buffers.get_raw_mut()))

        for(by_ref=false) framebuffer, i in self.swapchain.get().get_framebuffers() {
            begin_info := VkCommandBufferBeginInfo(
                sType            = .CommandBufferBeginInfo
                pInheritanceInfo = null
            )

            vk_try(vkBeginCommandBuffer(*command_buffers[i], ^begin_info))

            clear_color := VkClearValue.color(VkClearColorValue.float32([0.1, 0.1, 0.1, 1.0]))
            render_pass_info := VkRenderPassBeginInfo(
                sType           = .RenderPassBeginInfo
                renderPass      = self.render_pass
                framebuffer     = framebuffer
                renderArea      = VkRect2D(
                    offset      = VkOffset2D(0, 0)
                    extent      = self.swapchain.get().extent
                )
                clearValueCount = 1
                pClearValues    = ^clear_color
            )
            vkCmdBeginRenderPass(*command_buffers[i], ^render_pass_info, .Inline)
            vkCmdBindPipeline(*command_buffers[i], .Graphics, self.graphics_pipeline)
            
            viewport := VkViewport(
                x        = 0.0
                y        = 0.0
                width    = cast(float) self.swapchain.get().extent.width
                height   = cast(float) self.swapchain.get().extent.height
                minDepth = 0.0
                maxDepth = 1.0
            )

            scissor := VkRect2D(
                offset = VkOffset2D(0, 0)
                extent = self.swapchain.get().extent
            )

            vkCmdSetViewport(*command_buffers[i], 0, 1, ^viewport)
            vkCmdSetScissor(*command_buffers[i], 0, 1, ^scissor)

            vkCmdDraw(*command_buffers[i], 3, 1, 0, 0)
            vkCmdEndRenderPass(*command_buffers[i])
            vk_try(vkEndCommandBuffer(*command_buffers[i]))
        }


        return Ok()
    }

    //////////////////////////////////////////
    // stuff for creating semaphores
    //////////////////////////////////////////

    create_sync_objects :: (&mut Self) -> Result[(), String] {
        self.sema_image_available.resize(MaxFramesInFlight)
        self.sema_render_finished.resize(MaxFramesInFlight)
        self.fences_in_flight.resize(MaxFramesInFlight)
        self.images_in_flight.resize(self.swapchain.get().images.count())

        semaphore_info := VkSemaphoreCreateInfo(
            sType = .SemaphoreCreateInfo
        )

        fence_info := VkFenceCreateInfo(
            sType = .FenceCreateInfo
            flags = .SignaledBit
        )

        for i in 0 .. MaxFramesInFlight {
            vk_try(vkCreateSemaphore(self.context.device.handle, ^semaphore_info, null, ^mut *self.sema_image_available[i]))
            vk_try(vkCreateSemaphore(self.context.device.handle, ^semaphore_info, null, ^mut *self.sema_render_finished[i]))
            vk_try(vkCreateFence(self.context.device.handle, ^fence_info, null, ^mut *self.fences_in_flight[i]))
        }

        return Ok()
    }
}