use import std.array
use import std.map
use import std.box
use import std.string
use import std.math
use import std.matrix

mem :: import std.mem.allocator
fmt :: import std.fmt
io  :: import std.io
C   :: import std.c
fs  :: import std.io.fs

use import glfw
use import vulkan
use import vulkan_utils
use import spirv_cross

vk :: import vulkan_hl

MaxFramesInFlight :: 2

enable_validation_layers :: true
validation_layers := [
    "VK_LAYER_KHRONOS_validation"c
]
device_extensions := [
    VK_KHR_SWAPCHAIN_EXTENSION_NAME
]

glfw_error_callback :: (error: i32, description: ^mut char8) {
    desc := String.from_cstring(description)
    io.formatln("Glfw Error {}: {}", [error, desc.slice()])
}

vulkan_debug_callback :: (
    messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT,
    messageType: VkDebugUtilsMessageTypeFlagsEXT,
    pCallbackData: ^mut VkDebugUtilsMessengerCallbackDataEXT,
    pUserData: ^mut void) -> VkBool32 #stdcall {

    if i32(messageSeverity) >= i32(VkDebugUtilsMessageSeverityFlagBitsEXT.WarningBitExt) {
        level := match messageSeverity {
            .VerboseBitExt  -> "Verbose"
            .InfoBitExt     -> "Info"
            .WarningBitExt  -> "Warning"
            .ErrorBitExt    -> "Error"
            _               -> "?"
        }

        io.formatln("[Vulkan {}] {}", [level, string.from_cstring(pCallbackData.pMessage)])
    }

    return VK_FALSE
}

Main :: () {
    // window := match create_window(800, 600) {
    //     Ok($window) -> window
    //     Err($err) -> {
    //         io.formatln("GLFW error: {}", [err.slice()])
    //         return
    //     }
    // }

    // match app_main(window) {
    //     Ok() -> {}

    //     Err($err) -> {
    //         io.formatln("Vulkan app failed with error {}", [&err])
    //     }
    // }

    hello_triangle_app := HelloTriangleApplication.new()

    match hello_triangle_app.run() {
        Ok(_) -> {}
        Err($msg) -> {
            io.formatln("[Vulkan Error] {}", [msg])
        }
    }
}

app_main :: (window: ^GLFWwindow) -> Result[(), vk.Error] {
    context := try(VulkanContext.new(window))

    glfwShowWindow(cast window)
    while glfwWindowShouldClose(cast window) == 0 {
        glfwPollEvents()
        // draw_frame()
    }

    io.formatln("ok")

    return Ok()
}

create_window :: (width: int, height: int) -> Result[^GLFWwindow, String] {
    glfwSetErrorCallback(glfw_error_callback)

    window_size : (x: i32, y: i32) = i32(width), i32(height)

    if glfwInit() == 0 {
        return Err(fmt.format("Failed to initialize GLFW"))
    }

    glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE)
    glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE)
    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API)

    mut monitors: []mut ^mut GLFWmonitor = []
    monitors.data = glfwGetMonitors(cast ^mut monitors.length)

    @assert(monitors.length > 0)

    window := glfwCreateWindow(window_size.x, window_size.y, "Vulkan Test", null, null)
    if window == null {
        return Err(fmt.format("Failed to create window"))
    }

    // center window on monitor
    monitor := *monitors[0]
    vidmode := glfwGetVideoMode(monitor)
    monitor_pos : (x: i32, y: i32) = default
    glfwGetMonitorPos(monitor, ^monitor_pos.x, ^monitor_pos.y)
    glfwSetWindowPos(window, monitor_pos.x + vidmode.width / 2 - window_size.x / 2, monitor_pos.y + vidmode.height / 2 - window_size.y / 2)

    // glfwSetWindowUserPointer(window, ^mut *self)

    // glfwSetWindowSizeCallback(window, (window, width, height) => {
    //     app := cast(^mut HelloTriangleApplication) glfwGetWindowUserPointer(window)
    //     app.framebuffer_resized = true
    // })

    return Ok(window)
}

VulkanContext :: struct {
    instance        : vk.Instance
    debug_messenger : vk.DebugUtilsMessenger
    surface         : vk.Surface
    physical_device : vk.PhysicalDevice
    device          : vk.Device
    graphics_queue  : vk.Queue
    present_queue   : vk.Queue
}

impl VulkanContext {
    destroy :: (&Self) {
        self.device.destroy()
        self.surface.destroy()
        self.debug_messenger.destroy()
        self.instance.destroy()
    }
}

impl Drop for VulkanContext {
    drop :: (&Self) {
        self.destroy()
    }
}

impl VulkanContext {
    new :: (window: ^GLFWwindow) -> Result[^mut VulkanContext, vk.Error] {
        validation_info := vk.ValidationInfo(
            message_severity = .VerboseBitExt or .InfoBitExt or .WarningBitExt or .ErrorBitExt
            message_type     = .GeneralBitExt or .ValidationBitExt or .PerformanceBitExt
            user_callback    = vulkan_debug_callback
            user_data        = null
        )


        device_extensions := [string.from_cstring(VK_KHR_SWAPCHAIN_EXTENSION_NAME)]

        extensions := Array[string].new()

        // add extensions for glfw
        mut glfw_extensions : []^char8 = default
        glfw_extensions.data = glfwGetRequiredInstanceExtensions(cast ^mut glfw_extensions.length)
        for glfw_ext in glfw_extensions {
            extensions.add(string.from_cstring(glfw_ext))
        }

        instance := try(vk.Instance.new(
            api_version = Some(vk.Version((1, 2, 0)))
            validation  = Some(validation_info)
            extensions = extensions[..]
        ))

        debug_messenger := try(instance.create_debug_messenger(validation_info))
        surface := try(instance.create_surface_glfw(window))

        // find suitable physical device
        physical_devices := try(instance.enumerate_physical_devices())

        suitable_physical_devices := vk.PhysicalDevice.filter_by_requirements(physical_devices[..],
            extensions = device_extensions
            queues     = [vk.QueueFlags.GraphicsBit or .TransferBit]
            present    = Some(&surface)
            swapchain  = Some(&surface)
        )

        if suitable_physical_devices.count() == 0 {
            return Err(vk.Error.NoPhysicalDevice)
        }

        physical_device := *suitable_physical_devices[0]
        graphics_families := physical_device.get_queue_families_with(.GraphicsBit or .TransferBit)
        present_families := physical_device.get_queue_families_with_present(&surface)

        graphics_family := *graphics_families[0]
        present_family := *present_families[0]

        // create device
        unique_queue_families := Map[u32, ()].new()
        unique_queue_families.set(graphics_family, ())
        unique_queue_families.set(present_family, ())

        queue_create_infos := Array[vk.DeviceQueueCreateInfo].new(unique_queue_families.count())
        for kv in &unique_queue_families {
            queue_create_infos.add(vk.DeviceQueueCreateInfo(
                family      = *kv.key
                priorities  = [1.0]
            ))
        }

        features := VkPhysicalDeviceFeatures()
        device := try(vk.Device.new(physical_device,
            extensions = device_extensions
            queues = queue_create_infos[..]
            features = &features))
        graphics_queue := device.get_queue(graphics_family)
        present_queue := device.get_queue(present_family)

        result := mem.alloc(VulkanContext)
        *result = VulkanContext(
            instance        = instance
            debug_messenger = debug_messenger
            surface         = surface
            physical_device = *physical_device
            device          = device
            graphics_queue  = graphics_queue
            present_queue   = present_queue
        )
        return Ok(result)
    }
}

QueueFamilyIndices :: struct {
    graphics_family : Option[u32] = None
    present_family  : Option[u32] = None
}

impl QueueFamilyIndices {
    is_complete :: (&Self) -> bool {
        if self.graphics_family == .None {
            return false
        }
        if self.present_family == .None {
            return false
        }

        return true
    }
}

HelloTriangleApplication :: struct {
    // window stuff
    window                  : ^mut GLFWwindow = null
    window_size             : (x: i32, y: i32) = 800, 600

    current_frame           := 0
    framebuffer_resized     := false

    // vulkan stuff
    context                 : ^VulkanContext = null
    swapchain               : VkSwapchainKHR = null
    swapchain_images        := Array[VkImage].new()
    swapchain_image_views   := Array[VkImageView].new()
    swapchain_framebuffers  := Array[VkFramebuffer].new()
    swapchain_image_format  : VkFormat = default
    swapchain_extent        : VkExtent2D = default
    render_pass             : VkRenderPass = null
    pipeline_layout         : VkPipelineLayout = null
    graphics_pipeline       : VkPipeline = null
    command_pool            : VkCommandPool = null
    command_buffers         := Array[VkCommandBuffer].new()
    sema_image_available    := Array[VkSemaphore].new()
    sema_render_finished    := Array[VkSemaphore].new()
    fences_in_flight        := Array[VkFence].new()
    images_in_flight        := Array[VkFence].new()
}

impl HelloTriangleApplication {
    new :: () -> HelloTriangleApplication {
        return HelloTriangleApplication()
    }

    run :: (&mut Self) -> Result[(), String] {
        defer self.cleanup()

        // init stuff
        try(self.init_window())
        try(self.init_vulkan())

        self.main_loop()

        return Ok()
    }
    
    cleanup_swapchain :: (&mut Self) {
        for(by_ref=false) framebuffer in self.swapchain_framebuffers.slice() {
            if framebuffer  != null then vkDestroyFramebuffer(self.context.device.handle, framebuffer, null)
        }

        vkFreeCommandBuffers(self.context.device.handle, self.command_pool, cast self.command_buffers.count(), self.command_buffers.get_raw_mut())

        if graphics_pipeline!= null then vkDestroyPipeline(self.context.device.handle, graphics_pipeline, null)
        if pipeline_layout  != null then vkDestroyPipelineLayout(self.context.device.handle, pipeline_layout, null)
        if render_pass      != null then vkDestroyRenderPass(self.context.device.handle, render_pass, null)
        
        for(by_ref=false) view in self.swapchain_image_views.slice() {
            if view         != null then vkDestroyImageView(self.context.device.handle, view, null)
        }

        if swapchain        != null then vkDestroySwapchainKHR(self.context.device.handle, swapchain, null)
    }

    cleanup :: (&mut Self) {
        self.cleanup_swapchain()

        for i in 0 .. MaxFramesInFlight {
            if *sema_render_finished[i] != null then vkDestroySemaphore(self.context.device.handle, *sema_render_finished[i], null)
            if *sema_image_available[i] != null then vkDestroySemaphore(self.context.device.handle, *sema_image_available[i], null)
            if *fences_in_flight[i] != null then vkDestroyFence(self.context.device.handle, *fences_in_flight[i], null)
        }

        if command_pool     != null then vkDestroyCommandPool(self.context.device.handle, command_pool, null)

        self.context.destroy()
        mem.free(self.context)

        // glfw
        if window           != null then glfwDestroyWindow(window)
        glfwTerminate()
    }

    main_loop :: (&mut Self) {
        // show window
        glfwShowWindow(window)

        while glfwWindowShouldClose(window) == 0 {
            glfwPollEvents()
            draw_frame()
        }

        vkDeviceWaitIdle(self.context.device.handle)
    }

    draw_frame :: (&mut Self) {
        vkWaitForFences(self.context.device.handle, 1, ^*self.fences_in_flight[self.current_frame], VK_TRUE, u64.max)

        image_index : u32 = default
        match vkAcquireNextImageKHR(self.context.device.handle, self.swapchain, u64.max, *self.sema_image_available[self.current_frame], null, ^image_index) {
            .Success -> {}
            .SuboptimalKhr -> {}

            .ErrorOutOfDateKhr -> {
                self.recreate_swapchains()
                return
            }

            $err -> {
                io.formatln("[Vulkan Error] vkAcquireNextImageKHR returned {}", [err])
                @assert(false)
            }
        }

        // check if a previous frame is using this image
        if *self.images_in_flight[i64(image_index)] != null {
            vkWaitForFences(self.context.device.handle, 1, ^*self.images_in_flight[i64(image_index)], VK_TRUE, u64.max)
        }

        // mark the image as now being in use by this frame
        *self.images_in_flight[i64(image_index)] = *self.fences_in_flight[self.current_frame]

        wait_semaphores := [*self.sema_image_available[self.current_frame]]
        wait_stages := [VkPipelineStageFlagBits.ColorAttachmentOutputBit]
        signal_semaphores := [*self.sema_render_finished[self.current_frame]]
        submit_info := VkSubmitInfo(
            sType                = .SubmitInfo
            waitSemaphoreCount   = cast wait_semaphores.length
            pWaitSemaphores      = wait_semaphores.data
            pWaitDstStageMask    = wait_stages.data
            commandBufferCount   = 1
            pCommandBuffers      = ^*self.command_buffers[i64(image_index)]
            signalSemaphoreCount = cast signal_semaphores.length
            pSignalSemaphores    = signal_semaphores.data
        )

        vkResetFences(self.context.device.handle, 1, ^*self.fences_in_flight[self.current_frame])
        vk_assert(vkQueueSubmit(self.context.graphics_queue.handle, 1, ^submit_info, *self.fences_in_flight[self.current_frame]))

        swapchains := [self.swapchain]
        present_info := VkPresentInfoKHR(
            sType              = .PresentInfoKhr
            waitSemaphoreCount = cast signal_semaphores.length
            pWaitSemaphores    = signal_semaphores.data
            swapchainCount     = cast swapchains.length
            pSwapchains        = swapchains.data
            pImageIndices      = ^image_index
            pResults           = null
        )

        
        match vkQueuePresentKHR(self.context.present_queue.handle, ^present_info) {
            .Success -> {}
            .SuboptimalKhr -> {}

            .ErrorOutOfDateKhr -> {
                self.recreate_swapchains()
                return
            }

            $err -> {
                io.formatln("[Vulkan Error] vkQueuePresentKHR returned {}", [err])
                @assert(false)
            }
        }

        if self.framebuffer_resized {
            self.recreate_swapchains()
            return
        }

        self.current_frame = (self.current_frame + 1) % MaxFramesInFlight
    }
}

// window stull
impl HelloTriangleApplication {
    init_window :: (&mut Self) -> Result[(), String] {
        glfwSetErrorCallback(glfw_error_callback)

        if glfwInit() == 0 {
            return Err(fmt.format("Failed to initialize GLFW"))
        }

        glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE)
        glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE)
        glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API)

        mut monitors: []mut ^mut GLFWmonitor = []
        monitors.data = glfwGetMonitors(cast ^mut monitors.length)

        @assert(monitors.length > 0)

        window = glfwCreateWindow(self.window_size.x, self.window_size.y, "Vulkan Test", null, null)
        if window == null {
            return Err(fmt.format("Failed to create window"))
        }

        // center window on monitor
        monitor := *monitors[0]
        vidmode := glfwGetVideoMode(monitor)
        monitor_pos : (x: i32, y: i32) = default
        glfwGetMonitorPos(monitor, ^monitor_pos.x, ^monitor_pos.y)
        glfwSetWindowPos(window, monitor_pos.x + vidmode.width / 2 - self.window_size.x / 2, monitor_pos.y + vidmode.height / 2 - self.window_size.y / 2)

        glfwSetWindowUserPointer(window, ^mut *self)

        glfwSetWindowSizeCallback(window, (window, width, height) => {
            app := cast(^mut HelloTriangleApplication) glfwGetWindowUserPointer(window)
            app.framebuffer_resized = true
        })

        return Ok()
    }
}

SwapChainSupportDetails :: struct {
    capabilities    : VkSurfaceCapabilitiesKHR = default
    formats         := Array[VkSurfaceFormatKHR].new()
    present_modes   := Array[VkPresentModeKHR].new()
}

// vulkan stuff
impl HelloTriangleApplication {
    init_vulkan :: (&mut Self) -> Result[(), String] {
        // self.print_supported_extensions()

        self.context = try_with(VulkanContext.new(self.window), {
            return Err(fmt.format("Vulkan Error: {}", [err]))
        })

        try(self.create_swapchain())
        try(self.create_swapchain_image_views())
        try(self.create_render_pass())
        try(self.create_graphics_pipeline())
        try(self.create_framebuffers())
        try(self.create_command_pool())
        try(self.create_command_buffers())
        try(self.create_sync_objects())

        return Ok()
    }

    recreate_swapchains :: (&mut Self) -> Result[(), String] {
        self.framebuffer_resized = false

        
        mut width, height : (i32, i32) = default
        glfwGetFramebufferSize(self.window, ^mut width, ^mut height)
        while width == 0 or height == 0 {
            glfwGetFramebufferSize(self.window, ^mut width, ^mut height)
            glfwWaitEvents()
        }

        vkDeviceWaitIdle(self.context.device.handle)

        self.cleanup_swapchain()

        try(self.create_swapchain())
        try(self.create_swapchain_image_views())
        try(self.create_render_pass())
        try(self.create_graphics_pipeline())
        try(self.create_framebuffers())
        try(self.create_command_buffers())

        return Ok()
    }

    //////////////////////////////////////////
    // stuff for creating swapchain
    //////////////////////////////////////////

    find_queue_families :: (&mut Self, physical_device: VkPhysicalDevice) -> QueueFamilyIndices {
        mut indices := QueueFamilyIndices()
        queue_family_properties := Vulkan.get_physical_device_queue_family_properties(physical_device)

        for props, i in &mut queue_family_properties {
            // check graphics support
            if VkQueueFlagBits.GraphicsBit is in props.queueFlags {
                indices.graphics_family = Some(u32(i))
            }

            // check presentation support
            mut present_support : VkBool32 = 0
            vkGetPhysicalDeviceSurfaceSupportKHR(physical_device, cast i, self.context.surface.handle, ^mut present_support)
            if present_support != 0 {
                indices.present_family = Some(u32(i))
            }

            if indices.is_complete() {
                return indices
            }
        }

        return indices
    }
    
    query_swapchain_support :: (&mut Self, physical_device: VkPhysicalDevice) -> SwapChainSupportDetails {
        mut details := SwapChainSupportDetails(
            formats         = Vulkan.get_physical_device_surface_formats(physical_device, self.context.surface.handle)
            present_modes   = Vulkan.get_physical_device_surface_present_modes(physical_device, self.context.surface.handle)
        )

        vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physical_device, self.context.surface.handle, ^mut details.capabilities)

        return details
    }

    choose_swap_extent :: (&mut Self, capabilities: &VkSurfaceCapabilitiesKHR) -> VkExtent2D {
        if capabilities.currentExtent.width != u32.max {
            return capabilities.currentExtent
        }

        mut width, height : (i32, i32) = default
        glfwGetFramebufferSize(self.window, ^mut width, ^mut height)

        mut actual_extent := VkExtent2D(cast width, cast height)
        actual_extent.width = clamp(actual_extent.width, capabilities.minImageExtent.width, capabilities.maxImageExtent.width)
        actual_extent.height = clamp(actual_extent.height, capabilities.minImageExtent.height, capabilities.maxImageExtent.height)

        return actual_extent
    }

    choose_swap_present_mode :: (&mut Self, available_modes: &mut Array[VkPresentModeKHR]) -> VkPresentModeKHR {
        for(by_ref=false) mode in available_modes {
            if mode == .MailboxKhr {
                return mode
            }
        }

        return .FifoKhr
    }

    choose_swap_surface_format :: (&mut Self, available_formats: &mut Array[VkSurfaceFormatKHR]) -> VkSurfaceFormatKHR {
        for format in available_formats {
            if format.format == .B8g8r8a8Srgb and format.colorSpace == .SrgbNonlinearKhr {
                return *format
            }
        }

        return *available_formats[0]
    }

    create_swapchain :: (&mut Self) -> Result[(), String] {
        mut swapchain_support := self.query_swapchain_support(self.context.physical_device.handle)

        surface_format := choose_swap_surface_format(&mut swapchain_support.formats)
        present_mode := choose_swap_present_mode(&mut swapchain_support.present_modes)
        extent := choose_swap_extent(&swapchain_support.capabilities)
        mut image_count := swapchain_support.capabilities.minImageCount + 1
        if swapchain_support.capabilities.maxImageCount > 0 and image_count > swapchain_support.capabilities.maxImageCount {
            image_count = swapchain_support.capabilities.maxImageCount
        }

        io.formatln("[Vulkan] swapchain surface format  : {}", [surface_format])
        io.formatln("[Vulkan] swapchain present mode    : {}", [present_mode])
        io.formatln("[Vulkan] swapchain extent          : {}", [extent])
        io.formatln("[Vulkan] swapchain image count     : {}", [image_count])

        mut create_info := VkSwapchainCreateInfoKHR(
            sType                   = .SwapchainCreateInfoKhr
            surface                 = self.context.surface.handle
            minImageCount           = image_count
            imageFormat             = surface_format.format
            imageColorSpace         = surface_format.colorSpace
            imageExtent             = extent
            imageArrayLayers        = 1
            imageUsage              = VkImageUsageFlagBits.ColorAttachmentBit
            preTransform            = swapchain_support.capabilities.currentTransform
            compositeAlpha          = .OpaqueBitKhr
            presentMode             = present_mode
            clipped                 = VK_TRUE
            oldSwapchain            = null
        )

        indices := self.find_queue_families(self.context.physical_device.handle)
        queue_family_indices := [indices.graphics_family.unwrap(), indices.present_family.unwrap()]
        if indices.graphics_family.unwrap() != indices.present_family.unwrap() {
            create_info.imageSharingMode = .Concurrent
            create_info.queueFamilyIndexCount = cast queue_family_indices.length
            create_info.pQueueFamilyIndices = queue_family_indices.data
        } else {
            create_info.imageSharingMode = .Exclusive
            create_info.queueFamilyIndexCount = 0
            create_info.pQueueFamilyIndices = null
        }

        vk_try(vkCreateSwapchainKHR(self.context.device.handle, ^create_info, null, ^mut self.swapchain))

        // get handles to images in swapchain
        vkGetSwapchainImagesKHR(self.context.device.handle, self.swapchain, ^mut image_count, null)
        self.swapchain_images.resize(cast image_count)
        vkGetSwapchainImagesKHR(self.context.device.handle, self.swapchain, ^mut image_count, self.swapchain_images.get_raw_mut())

        self.swapchain_image_format = surface_format.format
        self.swapchain_extent = extent

        return Ok()
    }

    //////////////////////////////////////////
    // stuff for creating swapchain image views
    //////////////////////////////////////////

    create_swapchain_image_views :: (&mut Self) -> Result[(), String] {
        self.swapchain_image_views.resize(self.swapchain_images.count())

        for image, i in self.swapchain_images.slice() {
            create_info := VkImageViewCreateInfo(
                sType            = .ImageViewCreateInfo
                image            = image
                viewType         = ._2d
                format           = self.swapchain_image_format
                components       = VkComponentMapping(
                    r = .Identity
                    g = .Identity
                    b = .Identity
                    a = .Identity
                )
                subresourceRange = VkImageSubresourceRange(
                    aspectMask     = VkImageAspectFlagBits.ColorBit
                    baseMipLevel   = 0
                    levelCount     = 1
                    baseArrayLayer = 0
                    layerCount     = 1
                )
            )

            vk_try(vkCreateImageView(self.context.device.handle, ^create_info, null, ^mut *self.swapchain_image_views[i]))
        }

        return Ok()
    }

    //////////////////////////////////////////
    // stuff for creating render pass
    //////////////////////////////////////////

    create_render_pass :: (&mut Self) -> Result[(), String] {
        color_attachment := VkAttachmentDescription(
            format         = self.swapchain_image_format
            samples        = ._1Bit
            loadOp         = .Clear
            storeOp        = .Store
            stencilLoadOp  = .DontCare
            stencilStoreOp = .DontCare
            initialLayout  = .Undefined
            finalLayout    = .PresentSrcKhr
        )

        color_attachment_ref := VkAttachmentReference(
            attachment = 0
            layout     = .ColorAttachmentOptimal
        )

        subpass := VkSubpassDescription(
            pipelineBindPoint       = .Graphics
            inputAttachmentCount    = 0
            pInputAttachments       = null
            colorAttachmentCount    = 1
            pColorAttachments       = ^color_attachment_ref
            pResolveAttachments     = null
            pDepthStencilAttachment = null
            preserveAttachmentCount = 0
            pPreserveAttachments    = null
        )

        dependency := VkSubpassDependency(
            srcSubpass      = VK_SUBPASS_EXTERNAL
            dstSubpass      = 0
            srcStageMask    = .ColorAttachmentOutputBit
            dstStageMask    = .ColorAttachmentOutputBit
            srcAccessMask   = .None
            dstAccessMask   = .ColorAttachmentWriteBit
        )

        render_pass_info := VkRenderPassCreateInfo(
            sType           = .RenderPassCreateInfo
            attachmentCount = 1
            pAttachments    = ^color_attachment
            subpassCount    = 1
            pSubpasses      = ^subpass
            dependencyCount = 1
            pDependencies   = ^dependency
        )

        vk_try(vkCreateRenderPass(self.context.device.handle, ^render_pass_info, null, ^mut self.render_pass))

        return Ok()
    }

    //////////////////////////////////////////
    // stuff for creating pipeline
    //////////////////////////////////////////

    create_shader_module :: (&mut Self, code: []u8) -> Result[VkShaderModule, String] {
        create_info := VkShaderModuleCreateInfo(
            sType    = .ShaderModuleCreateInfo
            codeSize = cast code.length
            pCode    = cast(^mut u32) code.data
        )

        mut shader_module : VkShaderModule = default
        vk_try(vkCreateShaderModule(self.context.device.handle, ^create_info, null, ^mut shader_module))

        return Ok(shader_module)
    }

    create_graphics_pipeline :: (&mut Self) -> Result[(), String] {
        vert_shader_code := try_with(fs.read_file_binary("bin/triangle_vertex.spv"), { return Err(fmt.format("Failed to load vertex shader: {}", [err])) })
        frag_shader_code := try_with(fs.read_file_binary("bin/triangle_fragment.spv"), { return Err(fmt.format("Failed to load fragment shader: {}", [err])) })

        vert_shader_module := try(self.create_shader_module(vert_shader_code.slice()))
        defer vkDestroyShaderModule(self.context.device.handle, vert_shader_module, null)

        frag_shader_module := try(self.create_shader_module(frag_shader_code.slice()))
        defer vkDestroyShaderModule(self.context.device.handle, frag_shader_module, null)

        vert_shader_stage_info := VkPipelineShaderStageCreateInfo(
            sType               = .PipelineShaderStageCreateInfo
            stage               = .VertexBit
            module              = vert_shader_module
            pName               = "main"c
        )

        frag_shader_stage_info := VkPipelineShaderStageCreateInfo(
            sType               = .PipelineShaderStageCreateInfo
            stage               = .FragmentBit
            module              = frag_shader_module
            pName               = "main"c
        )

        shader_stages := [vert_shader_stage_info, frag_shader_stage_info]

        vertex_input_info := VkPipelineVertexInputStateCreateInfo(
            sType                           = .PipelineVertexInputStateCreateInfo
            vertexBindingDescriptionCount   = 0
            pVertexBindingDescriptions      = null
            vertexAttributeDescriptionCount = 0
            pVertexAttributeDescriptions    = null
        )

        input_assembly := VkPipelineInputAssemblyStateCreateInfo(
            sType                  = .PipelineInputAssemblyStateCreateInfo
            topology               = .TriangleList
            primitiveRestartEnable = VK_FALSE
        )

        viewport := VkViewport(
            x        = 0.0
            y        = 0.0
            width    = cast(float) self.swapchain_extent.width
            height   = cast(float) self.swapchain_extent.height
            minDepth = 0.0
            maxDepth = 1.0
        )

        scissor := VkRect2D(
            offset = VkOffset2D(0, 0)
            extent = self.swapchain_extent
        )

        viewport_state := VkPipelineViewportStateCreateInfo(
            sType         = .PipelineViewportStateCreateInfo
            viewportCount = 1
            pViewports    = ^viewport
            scissorCount  = 1
            pScissors     = ^scissor
        )

        rasterizer := VkPipelineRasterizationStateCreateInfo(
            sType                   = .PipelineRasterizationStateCreateInfo
            depthClampEnable        = VK_FALSE
            rasterizerDiscardEnable = VK_FALSE
            polygonMode             = .Fill
            cullMode                = .BackBit
            frontFace               = .Clockwise
            depthBiasEnable         = VK_FALSE
            depthBiasConstantFactor = 0.0
            depthBiasClamp          = 0.0
            depthBiasSlopeFactor    = 0.0
            lineWidth               = 1.0
        )

        multisampling := VkPipelineMultisampleStateCreateInfo(
            sType                 = .PipelineMultisampleStateCreateInfo
            rasterizationSamples  = ._1Bit
            sampleShadingEnable   = VK_FALSE
            minSampleShading      = 1.0
            pSampleMask           = null
            alphaToCoverageEnable = VK_FALSE
            alphaToOneEnable      = VK_FALSE
        )

        color_blend_attachment := VkPipelineColorBlendAttachmentState(
            blendEnable         = VK_FALSE
            srcColorBlendFactor = .One
            dstColorBlendFactor = .Zero
            colorBlendOp        = .Add
            srcAlphaBlendFactor = .One
            dstAlphaBlendFactor = .Zero
            alphaBlendOp        = .Add
            colorWriteMask      = .RBit or .GBit or .BBit or .ABit
        )

        color_blending := VkPipelineColorBlendStateCreateInfo(
            sType           = .PipelineColorBlendStateCreateInfo
            logicOpEnable   = VK_FALSE
            logicOp         = .Copy
            attachmentCount = 1
            pAttachments    = ^color_blend_attachment
            blendConstants  = [0.0, 0.0, 0.0, 0.0]
        )

        pipline_layout_info := VkPipelineLayoutCreateInfo(
            sType                  = .PipelineLayoutCreateInfo
            setLayoutCount         = 0
            pSetLayouts            = null
            pushConstantRangeCount = 0
            pPushConstantRanges    = null
        )

        vk_try(vkCreatePipelineLayout(self.context.device.handle, ^pipline_layout_info, null, ^mut self.pipeline_layout))

        pipeline_info := VkGraphicsPipelineCreateInfo(
            sType               = .GraphicsPipelineCreateInfo
            stageCount          = 2
            pStages             = shader_stages.data
            pVertexInputState   = ^vertex_input_info
            pInputAssemblyState = ^input_assembly
            pTessellationState  = null
            pViewportState      = ^viewport_state
            pRasterizationState = ^rasterizer
            pMultisampleState   = ^multisampling
            pDepthStencilState  = null
            pColorBlendState    = ^color_blending
            pDynamicState       = null
            layout              = self.pipeline_layout
            renderPass          = self.render_pass
            subpass             = 0
            basePipelineHandle  = null
            basePipelineIndex   = -1
        )

        vk_try(vkCreateGraphicsPipelines(self.context.device.handle, null, 1, ^pipeline_info, null, ^mut self.graphics_pipeline))

        return Ok()
    }

    //////////////////////////////////////////
    // stuff for creating framebuffers
    //////////////////////////////////////////

    create_framebuffers :: (&mut Self) -> Result[(), String] {
        self.swapchain_framebuffers.resize(self.swapchain_image_views.count())

        for(by_ref=false) view, i in self.swapchain_image_views.slice() {
            attachments := [view]
            framebuffer_info := VkFramebufferCreateInfo(
                sType           = .FramebufferCreateInfo
                renderPass      = self.render_pass
                attachmentCount = 1
                pAttachments    = attachments.data
                width           = self.swapchain_extent.width
                height          = self.swapchain_extent.height
                layers          = 1
            )

            vk_try(vkCreateFramebuffer(self.context.device.handle, ^framebuffer_info, null, ^mut *self.swapchain_framebuffers[i]))
        }

        return Ok()
    }

    //////////////////////////////////////////
    // stuff for creating command pool
    //////////////////////////////////////////

    create_command_pool :: (&mut Self) -> Result[(), String] {
        queue_family_indices := find_queue_families(self.context.physical_device.handle)

        pool_info := VkCommandPoolCreateInfo(
            sType            = .CommandPoolCreateInfo
            queueFamilyIndex = queue_family_indices.graphics_family.unwrap()
        )

        vk_try(vkCreateCommandPool(self.context.device.handle, ^pool_info, null, ^mut self.command_pool))

        return Ok()
    }

    //////////////////////////////////////////
    // stuff for creating command buffers
    //////////////////////////////////////////

    create_command_buffers :: (&mut Self) -> Result[(), String] {
        self.command_buffers.resize(self.swapchain_framebuffers.count())

        alloc_info := VkCommandBufferAllocateInfo(
            sType              = .CommandBufferAllocateInfo
            commandPool        = self.command_pool
            level              = .Primary
            commandBufferCount = cast self.command_buffers.count()
        )

        vk_try(vkAllocateCommandBuffers(self.context.device.handle, ^alloc_info, self.command_buffers.get_raw_mut()))

        for(by_ref=false) framebuffer, i in self.swapchain_framebuffers.slice() {
            begin_info := VkCommandBufferBeginInfo(
                sType            = .CommandBufferBeginInfo
                pInheritanceInfo = null
            )

            vk_try(vkBeginCommandBuffer(*command_buffers[i], ^begin_info))

            clear_color := VkClearValue.color(VkClearColorValue.float32([0.1, 0.1, 0.1, 1.0]))
            render_pass_info := VkRenderPassBeginInfo(
                sType           = .RenderPassBeginInfo
                renderPass      = self.render_pass
                framebuffer     = framebuffer
                renderArea      = VkRect2D(
                    offset      = VkOffset2D(0, 0)
                    extent      = self.swapchain_extent
                )
                clearValueCount = 1
                pClearValues    = ^clear_color
            )
            vkCmdBeginRenderPass(*command_buffers[i], ^render_pass_info, .Inline)
            vkCmdBindPipeline(*command_buffers[i], .Graphics, self.graphics_pipeline)
            vkCmdDraw(*command_buffers[i], 3, 1, 0, 0)
            vkCmdEndRenderPass(*command_buffers[i])
            vk_try(vkEndCommandBuffer(*command_buffers[i]))
        }


        return Ok()
    }

    //////////////////////////////////////////
    // stuff for creating semaphores
    //////////////////////////////////////////

    create_sync_objects :: (&mut Self) -> Result[(), String] {
        self.sema_image_available.resize(MaxFramesInFlight)
        self.sema_render_finished.resize(MaxFramesInFlight)
        self.fences_in_flight.resize(MaxFramesInFlight)
        self.images_in_flight.resize(self.swapchain_images.count())

        semaphore_info := VkSemaphoreCreateInfo(
            sType = .SemaphoreCreateInfo
        )

        fence_info := VkFenceCreateInfo(
            sType = .FenceCreateInfo
            flags = .SignaledBit
        )

        for i in 0 .. MaxFramesInFlight {
            vk_try(vkCreateSemaphore(self.context.device.handle, ^semaphore_info, null, ^mut *self.sema_image_available[i]))
            vk_try(vkCreateSemaphore(self.context.device.handle, ^semaphore_info, null, ^mut *self.sema_render_finished[i]))
            vk_try(vkCreateFence(self.context.device.handle, ^fence_info, null, ^mut *self.fences_in_flight[i]))
        }

        return Ok()
    }
}