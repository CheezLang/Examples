use import std.array
use import std.map
use import std.box
use import std.string
use import std.math
use import std.matrix
use import std.rc

mem :: import std.mem.allocator
fmt :: import std.fmt
io  :: import std.io
C   :: import std.c
fs  :: import std.io.fs

use import glfw
use import vulkan
use import vulkan_utils
use import spirv_cross

vk :: import vulkan_hl

MaxFramesInFlight :: 2

enable_validation_layers :: true
validation_layers := [
    "VK_LAYER_KHRONOS_validation"c
]
device_extensions := [
    VK_KHR_SWAPCHAIN_EXTENSION_NAME
]

glfw_error_callback :: (error: i32, description: ^mut char8) {
    desc := String.from_cstring(description)
    io.formatln("Glfw Error {}: {}", [error, desc.slice()])
}

vulkan_debug_callback :: (
    messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT,
    messageType: VkDebugUtilsMessageTypeFlagsEXT,
    pCallbackData: ^mut VkDebugUtilsMessengerCallbackDataEXT,
    pUserData: ^mut void) -> VkBool32 #stdcall {

    if i32(messageSeverity) >= i32(VkDebugUtilsMessageSeverityFlagBitsEXT.WarningBitExt) {
        level := match messageSeverity {
            .VerboseBitExt  -> "Verbose"
            .InfoBitExt     -> "Info"
            .WarningBitExt  -> "Warning"
            .ErrorBitExt    -> "Error"
            _               -> "?"
        }

        io.formatln("[Vulkan {}] {}", [level, string.from_cstring(pCallbackData.pMessage)])
    }

    return VK_FALSE
}

Main :: () {
    // window := match create_window(800, 600) {
    //     Ok($window) -> window
    //     Err($err) -> {
    //         io.formatln("GLFW error: {}", [err.slice()])
    //         return
    //     }
    // }

    // match app_main(window) {
    //     Ok() -> {}

    //     Err($err) -> {
    //         io.formatln("Vulkan app failed with error {}", [&err])
    //     }
    // }

    hello_triangle_app := HelloTriangleApplication.new()

    match hello_triangle_app.run() {
        Ok(_) -> {}
        Err($msg) -> {
            io.formatln("[Vulkan Error] {}", [msg])
        }
    }
}

app_main :: (window: ^GLFWwindow) -> Result[(), vk.Error] {
    context := try(VulkanContext.new(window))

    glfwShowWindow(cast window)
    while glfwWindowShouldClose(cast window) == 0 {
        glfwPollEvents()
        // draw_frame()
    }

    io.formatln("ok")

    return Ok()
}

create_window :: (width: int, height: int) -> Result[^GLFWwindow, String] {
    glfwSetErrorCallback(glfw_error_callback)

    window_size : (x: i32, y: i32) = i32(width), i32(height)

    if glfwInit() == 0 {
        return Err(fmt.format("Failed to initialize GLFW"))
    }

    glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE)
    glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE)
    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API)

    mut monitors: []mut ^mut GLFWmonitor = []
    monitors.data = glfwGetMonitors(cast ^mut monitors.length)

    @assert(monitors.length > 0)

    window := glfwCreateWindow(window_size.x, window_size.y, "Vulkan Test", null, null)
    if window == null {
        return Err(fmt.format("Failed to create window"))
    }

    // center window on monitor
    monitor := *monitors[0]
    vidmode := glfwGetVideoMode(monitor)
    monitor_pos : (x: i32, y: i32) = default
    glfwGetMonitorPos(monitor, ^monitor_pos.x, ^monitor_pos.y)
    glfwSetWindowPos(window, monitor_pos.x + vidmode.width / 2 - window_size.x / 2, monitor_pos.y + vidmode.height / 2 - window_size.y / 2)

    // glfwSetWindowUserPointer(window, ^mut *self)

    // glfwSetWindowSizeCallback(window, (window, width, height) => {
    //     app := cast(^mut HelloTriangleApplication) glfwGetWindowUserPointer(window)
    //     app.framebuffer_resized = true
    // })

    return Ok(window)
}

VulkanContext :: struct {
    instance        : vk.Instance
    debug_messenger : vk.DebugUtilsMessenger
    surface         : vk.Surface
    physical_device : vk.PhysicalDevice
    device          : vk.Device
    graphics_queue  : vk.Queue
    present_queue   : vk.Queue
    graphics_queue_family : u32
    present_queue_family  : u32
}

impl VulkanContext {
    destroy :: (&Self) {
        self.device.destroy()
        self.surface.destroy()
        self.debug_messenger.destroy()
        self.instance.destroy()
    }
}

impl Drop for VulkanContext {
    drop :: (&Self) {
        self.destroy()
    }
}

impl VulkanContext {
    new :: (window: ^GLFWwindow) -> Result[^mut VulkanContext, vk.Error] {
        validation_info := vk.ValidationInfo(
            message_severity = .VerboseBitExt or .InfoBitExt or .WarningBitExt or .ErrorBitExt
            message_type     = .GeneralBitExt or .ValidationBitExt or .PerformanceBitExt
            user_callback    = vulkan_debug_callback
            user_data        = null
        )


        device_extensions := [string.from_cstring(VK_KHR_SWAPCHAIN_EXTENSION_NAME)]

        extensions := Array[string].new()

        // add extensions for glfw
        mut glfw_extensions : []^char8 = default
        glfw_extensions.data = glfwGetRequiredInstanceExtensions(cast ^mut glfw_extensions.length)
        for glfw_ext in glfw_extensions {
            extensions.add(string.from_cstring(glfw_ext))
        }

        instance := try(vk.Instance.new(
            api_version = Some(vk.Version((1, 2, 0)))
            validation  = Some(validation_info)
            extensions = extensions[..]
        ))

        debug_messenger := try(instance.create_debug_messenger(validation_info))
        surface := try(instance.create_surface_glfw(window))

        // find suitable physical device
        physical_devices := try(instance.enumerate_physical_devices())

        suitable_physical_devices := vk.PhysicalDevice.filter_by_requirements(physical_devices[..],
            extensions = device_extensions
            queues     = [vk.QueueFlags.GraphicsBit or .TransferBit]
            present    = Some(&surface)
            swapchain  = Some(&surface)
        )

        if suitable_physical_devices.count() == 0 {
            return Err(vk.Error.NoPhysicalDevice)
        }

        physical_device := *suitable_physical_devices[0]
        graphics_families := physical_device.get_queue_families_with(.GraphicsBit or .TransferBit)
        present_families := physical_device.get_queue_families_with_present(&surface)

        graphics_family := *graphics_families[0]
        present_family := *present_families[0]

        // create device
        unique_queue_families := Map[u32, ()].new()
        unique_queue_families.set(graphics_family, ())
        unique_queue_families.set(present_family, ())

        queue_create_infos := Array[vk.DeviceQueueCreateInfo].new(unique_queue_families.count())
        for kv in &unique_queue_families {
            queue_create_infos.add(vk.DeviceQueueCreateInfo(
                family      = *kv.key
                priorities  = [1.0]
            ))
        }

        features := VkPhysicalDeviceFeatures()
        device := try(vk.Device.new(physical_device,
            extensions = device_extensions
            queues = queue_create_infos[..]
            features = &features))
        graphics_queue := device.get_queue(graphics_family)
        present_queue := device.get_queue(present_family)

        result := mem.alloc(VulkanContext)
        *result = VulkanContext(
            instance        = instance
            debug_messenger = debug_messenger
            surface         = surface
            physical_device = *physical_device
            device          = device
            graphics_queue  = graphics_queue
            present_queue   = present_queue
            graphics_queue_family = graphics_family
            present_queue_family  = present_family
        )
        return Ok(result)
    }
}

QueueFamilyIndices :: struct {
    graphics_family : Option[u32] = None
    present_family  : Option[u32] = None
}

impl QueueFamilyIndices {
    is_complete :: (&Self) -> bool {
        if self.graphics_family == .None {
            return false
        }
        if self.present_family == .None {
            return false
        }

        return true
    }
}

HelloTriangleApplication :: struct {
    // window stuff
    window                  : ^mut GLFWwindow = null
    window_size             : (x: i32, y: i32) = 800, 600

    current_frame           := 0
    framebuffer_resized     := false

    // vulkan stuff
    context                 : ^VulkanContext = null
    surface_capabilities    := Option[vk.PhysicalDeviceSurfaceCapabilities].None
    swapchain_format        : VkSurfaceFormatKHR = default
    swapchain               := Rc[vk.Swapchain].empty()
    render_pass             : VkRenderPass = null
    pipeline_layout         : VkPipelineLayout = null
    graphics_pipeline       : VkPipeline = null
    command_pool            : VkCommandPool = null
    command_buffers         := Array[VkCommandBuffer].new()
    sema_image_available    := Array[VkSemaphore].new()
    sema_render_finished    := Array[VkSemaphore].new()
    fences_in_flight        := Array[VkFence].new()
    images_in_flight        := Array[VkFence].new()
}

impl HelloTriangleApplication {
    new :: () -> HelloTriangleApplication {
        return HelloTriangleApplication()
    }

    run :: (&mut Self) -> Result[(), String] {
        defer self.cleanup()

        // init stuff
        try(self.init_window())
        try(self.init_vulkan())

        self.main_loop()

        return Ok()
    }
    
    cleanup_swapchain :: (&mut Self) {
        for(by_ref=false) framebuffer in self.swapchain.get().get_framebuffers() {
            if framebuffer  != null then vkDestroyFramebuffer(self.context.device.handle, framebuffer, null)
        }

        vkFreeCommandBuffers(self.context.device.handle, self.command_pool, cast self.command_buffers.count(), self.command_buffers.get_raw_mut())

        for(by_ref=false) view in self.swapchain.get().get_image_views() {
            if view         != null then vkDestroyImageView(self.context.device.handle, view, null)
        }

        swapchain.get().destroy()
    }

    cleanup :: (&mut Self) {
        if graphics_pipeline!= null then vkDestroyPipeline(self.context.device.handle, graphics_pipeline, null)
        if pipeline_layout  != null then vkDestroyPipelineLayout(self.context.device.handle, pipeline_layout, null)
        
        self.cleanup_swapchain()
        if render_pass != null then vkDestroyRenderPass(self.context.device.handle, render_pass, null)

        for i in 0 .. MaxFramesInFlight {
            if *sema_render_finished[i] != null then vkDestroySemaphore(self.context.device.handle, *sema_render_finished[i], null)
            if *sema_image_available[i] != null then vkDestroySemaphore(self.context.device.handle, *sema_image_available[i], null)
            if *fences_in_flight[i] != null then vkDestroyFence(self.context.device.handle, *fences_in_flight[i], null)
        }

        if command_pool     != null then vkDestroyCommandPool(self.context.device.handle, command_pool, null)

        self.context.destroy()
        mem.free(self.context)

        // glfw
        if window           != null then glfwDestroyWindow(window)
        glfwTerminate()
    }

    main_loop :: (&mut Self) {
        // show window
        glfwShowWindow(window)

        while glfwWindowShouldClose(window) == 0 {
            glfwPollEvents()
            draw_frame()
        }

        vkDeviceWaitIdle(self.context.device.handle)
    }

    draw_frame :: (&mut Self) {
        vkWaitForFences(self.context.device.handle, 1, ^*self.fences_in_flight[self.current_frame], VK_TRUE, u64.max)

        image_index : u32 = default
        match vkAcquireNextImageKHR(self.context.device.handle, self.swapchain.get().handle, u64.max, *self.sema_image_available[self.current_frame], null, ^image_index) {
            .Success -> {}
            .SuboptimalKhr -> {}

            .ErrorOutOfDateKhr -> {
                self.recreate_swapchains()
                return
            }

            $err -> {
                io.formatln("[Vulkan Error] vkAcquireNextImageKHR returned {}", [err])
                @assert(false)
            }
        }

        // check if a previous frame is using this image
        if *self.images_in_flight[i64(image_index)] != null {
            vkWaitForFences(self.context.device.handle, 1, ^*self.images_in_flight[i64(image_index)], VK_TRUE, u64.max)
        }

        // mark the image as now being in use by this frame
        *self.images_in_flight[i64(image_index)] = *self.fences_in_flight[self.current_frame]

        wait_semaphores := [*self.sema_image_available[self.current_frame]]
        wait_stages := [VkPipelineStageFlagBits.ColorAttachmentOutputBit]
        signal_semaphores := [*self.sema_render_finished[self.current_frame]]
        submit_info := VkSubmitInfo(
            sType                = .SubmitInfo
            waitSemaphoreCount   = cast wait_semaphores.length
            pWaitSemaphores      = wait_semaphores.data
            pWaitDstStageMask    = wait_stages.data
            commandBufferCount   = 1
            pCommandBuffers      = ^*self.command_buffers[i64(image_index)]
            signalSemaphoreCount = cast signal_semaphores.length
            pSignalSemaphores    = signal_semaphores.data
        )

        vkResetFences(self.context.device.handle, 1, ^*self.fences_in_flight[self.current_frame])
        vk_assert(vkQueueSubmit(self.context.graphics_queue.handle, 1, ^submit_info, *self.fences_in_flight[self.current_frame]))

        swapchains := [self.swapchain.get().handle]
        present_info := VkPresentInfoKHR(
            sType              = .PresentInfoKhr
            waitSemaphoreCount = cast signal_semaphores.length
            pWaitSemaphores    = signal_semaphores.data
            swapchainCount     = cast swapchains.length
            pSwapchains        = swapchains.data
            pImageIndices      = ^image_index
            pResults           = null
        )

        
        match vkQueuePresentKHR(self.context.present_queue.handle, ^present_info) {
            .Success -> {}
            .SuboptimalKhr -> {}

            .ErrorOutOfDateKhr -> {
                self.recreate_swapchains()
                return
            }

            $err -> {
                io.formatln("[Vulkan Error] vkQueuePresentKHR returned {}", [err])
                @assert(false)
            }
        }

        if self.framebuffer_resized {
            self.recreate_swapchains()
            return
        }

        self.current_frame = (self.current_frame + 1) % MaxFramesInFlight
    }
}

// window stull
impl HelloTriangleApplication {
    init_window :: (&mut Self) -> Result[(), String] {
        glfwSetErrorCallback(glfw_error_callback)

        if glfwInit() == 0 {
            return Err(fmt.format("Failed to initialize GLFW"))
        }

        glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE)
        glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE)
        glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API)

        mut monitors: []mut ^mut GLFWmonitor = []
        monitors.data = glfwGetMonitors(cast ^mut monitors.length)

        @assert(monitors.length > 0)

        window = glfwCreateWindow(self.window_size.x, self.window_size.y, "Vulkan Test", null, null)
        if window == null {
            return Err(fmt.format("Failed to create window"))
        }

        // center window on monitor
        monitor := *monitors[0]
        vidmode := glfwGetVideoMode(monitor)
        monitor_pos : (x: i32, y: i32) = default
        glfwGetMonitorPos(monitor, ^monitor_pos.x, ^monitor_pos.y)
        glfwSetWindowPos(window, monitor_pos.x + vidmode.width / 2 - self.window_size.x / 2, monitor_pos.y + vidmode.height / 2 - self.window_size.y / 2)

        glfwSetWindowUserPointer(window, ^mut *self)

        glfwSetWindowSizeCallback(window, (window, width, height) => {
            app := cast(^mut HelloTriangleApplication) glfwGetWindowUserPointer(window)
            app.framebuffer_resized = true
        })

        return Ok()
    }
}

// vulkan stuff
impl HelloTriangleApplication {
    init_vulkan :: (&mut Self) -> Result[(), String] {
        self.context = try_with(VulkanContext.new(self.window), { return Err(fmt.format("Failed to create context: {}", [err])) })
        self.surface_capabilities = Some(self.context.physical_device.query_swapchain_support(&self.context.surface))
        self.swapchain_format = self.surface_capabilities.unwrap_ref().choose_swap_surface_format(.R8g8b8a8Srgb, .SrgbNonlinearKhr)

        try(self.create_command_pool())
        
        mut window_extent := VkExtent2D()
        glfwGetFramebufferSize(self.window, cast ^mut window_extent.width, cast ^mut window_extent.height)

        self.swapchain = try_with(vk.Swapchain.new(
            device                  = &self.context.device
            physical_device         = &self.context.physical_device
            surface                 = &self.context.surface
            queue_family_indices    = [self.context.graphics_queue_family, self.context.present_queue_family]
            extent                  = self.surface_capabilities.unwrap_ref().choose_swap_extent(window_extent)
            image_format            = self.swapchain_format.format
            color_space             = self.swapchain_format.colorSpace
            present_mode            = self.surface_capabilities.unwrap_ref().choose_swap_present_mode(.MailboxKhr)
            image_count             = self.surface_capabilities.unwrap_ref().choose_image_count()
            pre_transform           = self.surface_capabilities.unwrap_ref().capabilities.currentTransform
        ), { return Err(fmt.format("Failed to create swapchain: {}", [err])) })

        try(self.create_render_pass())
        try(self.create_graphics_pipeline())

        try_with(self.swapchain.get_mut().create_image_views(), { return Err(fmt.format("Failed to create swapchain image views: {}", [err])) })
        try_with(self.swapchain.get_mut().create_framebuffers(self.render_pass), { return Err(fmt.format("Failed to create swapchain framebuffers: {}", [err])) })
        try(self.create_command_buffers())
        try(self.create_sync_objects())

        return Ok()
    }

    recreate_swapchains :: (&mut Self) -> Result[(), String] {
        self.framebuffer_resized = false

        mut window_extent := VkExtent2D()
        glfwGetFramebufferSize(self.window, cast ^mut window_extent.width, cast ^mut window_extent.height)
        while window_extent.width == 0 or window_extent.height == 0 {
            glfwGetFramebufferSize(self.window, cast ^mut window_extent.width, cast ^mut window_extent.height)
            glfwWaitEvents()
        }

        vkDeviceWaitIdle(self.context.device.handle)
        self.cleanup_swapchain()
        self.surface_capabilities.unwrap_ref_mut().update_capabilities(&self.context.surface)

        // create new swapchain
        self.swapchain = try_with(vk.Swapchain.new(
            device                  = &self.context.device
            physical_device         = &self.context.physical_device
            surface                 = &self.context.surface
            queue_family_indices    = [self.context.graphics_queue_family, self.context.present_queue_family]
            extent                  = self.surface_capabilities.unwrap_ref().choose_swap_extent(window_extent)
            image_format            = self.swapchain_format.format
            color_space             = self.swapchain_format.colorSpace
            present_mode            = self.surface_capabilities.unwrap_ref().choose_swap_present_mode(.MailboxKhr)
            image_count             = self.surface_capabilities.unwrap_ref().choose_image_count()
            pre_transform           = self.surface_capabilities.unwrap_ref().capabilities.currentTransform
        ), { return Err(fmt.format("Failed to create swapchain: {}", [err])) })
        try_with(self.swapchain.get_mut().create_image_views(), { return Err(fmt.format("Failed to create swapchain image views: {}", [err])) })
        try_with(self.swapchain.get_mut().create_framebuffers(self.render_pass), { return Err(fmt.format("Failed to create swapchain framebuffers: {}", [err])) })
        try(self.create_command_buffers())

        return Ok()
    }

    //////////////////////////////////////////
    // stuff for creating render pass
    //////////////////////////////////////////

    create_render_pass :: (&mut Self) -> Result[(), String] {
        color_attachment := VkAttachmentDescription(
            format         = self.swapchain.get().image_format
            samples        = ._1Bit
            loadOp         = .Clear
            storeOp        = .Store
            stencilLoadOp  = .DontCare
            stencilStoreOp = .DontCare
            initialLayout  = .Undefined
            finalLayout    = .PresentSrcKhr
        )

        color_attachment_ref := VkAttachmentReference(
            attachment = 0
            layout     = .ColorAttachmentOptimal
        )

        subpass := VkSubpassDescription(
            pipelineBindPoint       = .Graphics
            inputAttachmentCount    = 0
            pInputAttachments       = null
            colorAttachmentCount    = 1
            pColorAttachments       = ^color_attachment_ref
            pResolveAttachments     = null
            pDepthStencilAttachment = null
            preserveAttachmentCount = 0
            pPreserveAttachments    = null
        )

        dependency := VkSubpassDependency(
            srcSubpass      = VK_SUBPASS_EXTERNAL
            dstSubpass      = 0
            srcStageMask    = .ColorAttachmentOutputBit
            dstStageMask    = .ColorAttachmentOutputBit
            srcAccessMask   = .None
            dstAccessMask   = .ColorAttachmentWriteBit
        )

        render_pass_info := VkRenderPassCreateInfo(
            sType           = .RenderPassCreateInfo
            attachmentCount = 1
            pAttachments    = ^color_attachment
            subpassCount    = 1
            pSubpasses      = ^subpass
            dependencyCount = 1
            pDependencies   = ^dependency
        )

        vk_try(vkCreateRenderPass(self.context.device.handle, ^render_pass_info, null, ^mut self.render_pass))

        return Ok()
    }

    //////////////////////////////////////////
    // stuff for creating pipeline
    //////////////////////////////////////////

    create_shader_module :: (&mut Self, code: []u8) -> Result[VkShaderModule, String] {
        create_info := VkShaderModuleCreateInfo(
            sType    = .ShaderModuleCreateInfo
            codeSize = cast code.length
            pCode    = cast(^mut u32) code.data
        )

        mut shader_module : VkShaderModule = default
        vk_try(vkCreateShaderModule(self.context.device.handle, ^create_info, null, ^mut shader_module))

        return Ok(shader_module)
    }

    create_graphics_pipeline :: (&mut Self) -> Result[(), String] {
        vert_shader_code := try_with(fs.read_file_binary("bin/triangle_vertex.spv"), { return Err(fmt.format("Failed to load vertex shader: {}", [err])) })
        frag_shader_code := try_with(fs.read_file_binary("bin/triangle_fragment.spv"), { return Err(fmt.format("Failed to load fragment shader: {}", [err])) })

        vert_shader_module := try(self.create_shader_module(vert_shader_code.slice()))
        defer vkDestroyShaderModule(self.context.device.handle, vert_shader_module, null)

        frag_shader_module := try(self.create_shader_module(frag_shader_code.slice()))
        defer vkDestroyShaderModule(self.context.device.handle, frag_shader_module, null)

        vert_shader_stage_info := VkPipelineShaderStageCreateInfo(
            sType               = .PipelineShaderStageCreateInfo
            stage               = .VertexBit
            module              = vert_shader_module
            pName               = "main"c
        )

        frag_shader_stage_info := VkPipelineShaderStageCreateInfo(
            sType               = .PipelineShaderStageCreateInfo
            stage               = .FragmentBit
            module              = frag_shader_module
            pName               = "main"c
        )

        shader_stages := [vert_shader_stage_info, frag_shader_stage_info]

        vertex_input_info := VkPipelineVertexInputStateCreateInfo(
            sType                           = .PipelineVertexInputStateCreateInfo
            vertexBindingDescriptionCount   = 0
            pVertexBindingDescriptions      = null
            vertexAttributeDescriptionCount = 0
            pVertexAttributeDescriptions    = null
        )

        input_assembly := VkPipelineInputAssemblyStateCreateInfo(
            sType                  = .PipelineInputAssemblyStateCreateInfo
            topology               = .TriangleList
            primitiveRestartEnable = VK_FALSE
        )

        viewport_state := VkPipelineViewportStateCreateInfo(
            sType         = .PipelineViewportStateCreateInfo
            viewportCount = 1
            pViewports    = null
            scissorCount  = 1
            pScissors     = null
        )

        rasterizer := VkPipelineRasterizationStateCreateInfo(
            sType                   = .PipelineRasterizationStateCreateInfo
            depthClampEnable        = VK_FALSE
            rasterizerDiscardEnable = VK_FALSE
            polygonMode             = .Fill
            cullMode                = .BackBit
            frontFace               = .Clockwise
            depthBiasEnable         = VK_FALSE
            depthBiasConstantFactor = 0.0
            depthBiasClamp          = 0.0
            depthBiasSlopeFactor    = 0.0
            lineWidth               = 1.0
        )

        multisampling := VkPipelineMultisampleStateCreateInfo(
            sType                 = .PipelineMultisampleStateCreateInfo
            rasterizationSamples  = ._1Bit
            sampleShadingEnable   = VK_FALSE
            minSampleShading      = 1.0
            pSampleMask           = null
            alphaToCoverageEnable = VK_FALSE
            alphaToOneEnable      = VK_FALSE
        )

        color_blend_attachment := VkPipelineColorBlendAttachmentState(
            blendEnable         = VK_FALSE
            srcColorBlendFactor = .One
            dstColorBlendFactor = .Zero
            colorBlendOp        = .Add
            srcAlphaBlendFactor = .One
            dstAlphaBlendFactor = .Zero
            alphaBlendOp        = .Add
            colorWriteMask      = .RBit or .GBit or .BBit or .ABit
        )

        color_blending := VkPipelineColorBlendStateCreateInfo(
            sType           = .PipelineColorBlendStateCreateInfo
            logicOpEnable   = VK_FALSE
            logicOp         = .Copy
            attachmentCount = 1
            pAttachments    = ^color_blend_attachment
            blendConstants  = [0.0, 0.0, 0.0, 0.0]
        )

        pipline_layout_info := VkPipelineLayoutCreateInfo(
            sType                  = .PipelineLayoutCreateInfo
            setLayoutCount         = 0
            pSetLayouts            = null
            pushConstantRangeCount = 0
            pPushConstantRanges    = null
        )

        vk_try(vkCreatePipelineLayout(self.context.device.handle, ^pipline_layout_info, null, ^mut self.pipeline_layout))

        mut dynamic_states : []VkDynamicState = [ VkDynamicState.Scissor, VkDynamicState.Viewport ]
        dynamic_state := VkPipelineDynamicStateCreateInfo(
            sType               = .PipelineDynamicStateCreateInfo
            dynamicStateCount   = cast dynamic_states.length
            pDynamicStates      = cast(^mut VkDynamicState) dynamic_states.data
        )

        pipeline_info := VkGraphicsPipelineCreateInfo(
            sType               = .GraphicsPipelineCreateInfo
            stageCount          = 2
            pStages             = shader_stages.data
            pVertexInputState   = ^vertex_input_info
            pInputAssemblyState = ^input_assembly
            pTessellationState  = null
            pViewportState      = ^viewport_state
            pRasterizationState = ^rasterizer
            pMultisampleState   = ^multisampling
            pDepthStencilState  = null
            pColorBlendState    = ^color_blending
            pDynamicState       = ^dynamic_state
            layout              = self.pipeline_layout
            renderPass          = self.render_pass
            subpass             = 0
            basePipelineHandle  = null
            basePipelineIndex   = -1
        )

        vk_try(vkCreateGraphicsPipelines(self.context.device.handle, null, 1, ^pipeline_info, null, ^mut self.graphics_pipeline))

        return Ok()
    }
    
    //////////////////////////////////////////
    // stuff for creating command pool
    //////////////////////////////////////////

    create_command_pool :: (&mut Self) -> Result[(), String] {
        pool_info := VkCommandPoolCreateInfo(
            sType            = .CommandPoolCreateInfo
            queueFamilyIndex = self.context.graphics_queue_family
        )

        vk_try(vkCreateCommandPool(self.context.device.handle, ^pool_info, null, ^mut self.command_pool))

        return Ok()
    }

    //////////////////////////////////////////
    // stuff for creating command buffers
    //////////////////////////////////////////

    create_command_buffers :: (&mut Self) -> Result[(), String] {
        self.command_buffers.resize(self.swapchain.get().get_framebuffers().length)

        alloc_info := VkCommandBufferAllocateInfo(
            sType              = .CommandBufferAllocateInfo
            commandPool        = self.command_pool
            level              = .Primary
            commandBufferCount = cast self.command_buffers.count()
        )

        vk_try(vkAllocateCommandBuffers(self.context.device.handle, ^alloc_info, self.command_buffers.get_raw_mut()))

        for(by_ref=false) framebuffer, i in self.swapchain.get().get_framebuffers() {
            begin_info := VkCommandBufferBeginInfo(
                sType            = .CommandBufferBeginInfo
                pInheritanceInfo = null
            )

            vk_try(vkBeginCommandBuffer(*command_buffers[i], ^begin_info))

            clear_color := VkClearValue.color(VkClearColorValue.float32([0.1, 0.1, 0.1, 1.0]))
            render_pass_info := VkRenderPassBeginInfo(
                sType           = .RenderPassBeginInfo
                renderPass      = self.render_pass
                framebuffer     = framebuffer
                renderArea      = VkRect2D(
                    offset      = VkOffset2D(0, 0)
                    extent      = self.swapchain.get().extent
                )
                clearValueCount = 1
                pClearValues    = ^clear_color
            )
            vkCmdBeginRenderPass(*command_buffers[i], ^render_pass_info, .Inline)
            vkCmdBindPipeline(*command_buffers[i], .Graphics, self.graphics_pipeline)
            
            viewport := VkViewport(
                x        = 0.0
                y        = 0.0
                width    = cast(float) self.swapchain.get().extent.width
                height   = cast(float) self.swapchain.get().extent.height
                minDepth = 0.0
                maxDepth = 1.0
            )

            scissor := VkRect2D(
                offset = VkOffset2D(0, 0)
                extent = self.swapchain.get().extent
            )

            vkCmdSetViewport(*command_buffers[i], 0, 1, ^viewport)
            vkCmdSetScissor(*command_buffers[i], 0, 1, ^scissor)

            vkCmdDraw(*command_buffers[i], 3, 1, 0, 0)
            vkCmdEndRenderPass(*command_buffers[i])
            vk_try(vkEndCommandBuffer(*command_buffers[i]))
        }


        return Ok()
    }

    //////////////////////////////////////////
    // stuff for creating semaphores
    //////////////////////////////////////////

    create_sync_objects :: (&mut Self) -> Result[(), String] {
        self.sema_image_available.resize(MaxFramesInFlight)
        self.sema_render_finished.resize(MaxFramesInFlight)
        self.fences_in_flight.resize(MaxFramesInFlight)
        self.images_in_flight.resize(self.swapchain.get().images.count())

        semaphore_info := VkSemaphoreCreateInfo(
            sType = .SemaphoreCreateInfo
        )

        fence_info := VkFenceCreateInfo(
            sType = .FenceCreateInfo
            flags = .SignaledBit
        )

        for i in 0 .. MaxFramesInFlight {
            vk_try(vkCreateSemaphore(self.context.device.handle, ^semaphore_info, null, ^mut *self.sema_image_available[i]))
            vk_try(vkCreateSemaphore(self.context.device.handle, ^semaphore_info, null, ^mut *self.sema_render_finished[i]))
            vk_try(vkCreateFence(self.context.device.handle, ^fence_info, null, ^mut *self.fences_in_flight[i]))
        }

        return Ok()
    }
}